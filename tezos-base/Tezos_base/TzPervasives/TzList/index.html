<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TzList (tezos-base.Tezos_base.TzPervasives.TzList)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">tezos-base</a> &#x00BB; <a href="../../index.html">Tezos_base</a> &#x00BB; <a href="../index.html">TzPervasives</a> &#x00BB; TzList</nav><h1>Module <code>TzPervasives.TzList</code></h1></header><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>remove nb list</code> remove the first <code>nb</code> elements from the list <code>list</code>.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>repeat n x</code> is a list of <code>n</code> <code>x</code>'s</p></dd></dl><dl><dt class="spec value" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val</span> shift : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>shift (hd :: tl)</code> computes <code>tl @ [hd]</code></p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p><code>product a b</code> computes the Cartesian product of two lists <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_n"><a href="#val-take_n" class="anchor"></a><code><span class="keyword">val</span> take_n : <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>take_n n l</code> returns the <code>n</code> first elements of <code>l</code>. When <code>compare</code> is provided, it returns the <code>n</code> greatest element of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_n"><a href="#val-split_n" class="anchor"></a><code><span class="keyword">val</span> split_n : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>split_n n l</code> is a pair of lists <code>(j, k)</code> where <code>j</code> contains the <code>n</code> first elements of <code>l</code> and <code>k</code> the remainder elements. If <code>l</code> has less than or exactly <code>n</code> elements, <code>j</code> is <code>l</code> and <code>k</code> is <code>[]</code>.</p></dd></dl><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>select n l</code> is (<code>n</code>th element of <code>l</code>, <code>l</code> without that element)</p></dd></dl><dl><dt class="spec value" id="val-rev_sub"><a href="#val-rev_sub" class="anchor"></a><code><span class="keyword">val</span> rev_sub : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>rev_sub l n</code> is <code>List.rev l</code> capped to max <code>n</code> elements</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sub l n</code> is <code>l</code> capped to max <code>n</code> elements</p></dd></dl><dl><dt class="spec value" id="val-merge_filter2"><a href="#val-merge_filter2" class="anchor"></a><code><span class="keyword">val</span> merge_filter2 : <span>?&#8288;finalize:<span>(<span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;f:<span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>merge_filter2 ~compare ~f l1 l2</code> merges two lists ordered by <code>compare</code> and whose items can be merged with <code>f</code>. Item is discarded or kept whether <code>f</code> returns <code>Some</code> or <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-merge2"><a href="#val-merge2" class="anchor"></a><code><span class="keyword">val</span> merge2 : <span>?&#8288;finalize:<span>(<span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>merge2 ~compare ~f l1 l2</code> merges two lists ordered by <code>compare</code> and whose items can be merged with <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val</span> shuffle : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>shuffle l</code> is a list that contains the same elements as <code>l</code> but in a random order.</p></dd></dl><dl><dt class="spec value" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val</span> index_of : <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p>Get the index of an element in a list.</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>find_map f l</code> applies <code>f</code> to the elements of <code>l</code> in order, and returns the first result of the form <code>Some v</code>, or <code>None</code> if none exist.</p><p>Present in OCaml 4.10: this function can be removed once we catch up.</p></dd></dl></div></body></html>