<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TzTrace (tezos-base.Tezos_base.TzPervasives.Error_monad.TzTrace)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">tezos-base</a> &#x00BB; <a href="../../../index.html">Tezos_base</a> &#x00BB; <a href="../../index.html">TzPervasives</a> &#x00BB; <a href="../index.html">Error_monad</a> &#x00BB; TzTrace</nav><h1>Module <code>Error_monad.TzTrace</code></h1></header><dl><dt class="spec type" id="type-trace"><a href="#type-trace" class="anchor"></a><code><span class="keyword">type</span> <span>'error trace</span></code><code> = <span><span class="type-var">'error</span> list</span></code></dt><dd><p><code>trace</code> is abstract in this interface but it is made concrete in the instantiated error monad (see <code>error_monad.mli</code>).</p><p>The idea of abstracting the trace is so that it can evolve more easily. Eventually, we can make the trace abstract in the instantiated error monad, we can have different notions of traces for the protocol and the shell, etc.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span class="type-var">'error</span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span></code></dt><dd><p><code>make e</code> makes a singleton trace, the simplest of traces that carries a single error.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'error</span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span></code></dt><dd><p><code>cons e t</code> (construct sequential) constructs a sequential trace. This is for tracing events/failures/things that happen one after the other, generally one as a consequence of the other. E.g.,</p><p><code>let file_handle =
         match attempt_open name with
         | Ok handle -&gt; Ok handle
         | Error error -&gt;
               let trace = make error in
               match attempt_create name with
               | Ok handle -&gt; Ok handle
               | Error error -&gt; Error (cons error trace)
      </code></p><p>When you are within the error monad itself, you should build traces using the <code>record_trace</code>, <code>trace</code>, <code>record_trace_eval</code> and <code>trace_eval</code> functions directly. You should rarely need to build traces manually using <code>cons</code>. This here function can be useful in the case where you are at the interface of the error monad.</p></dd></dl><dl><dt class="spec value" id="val-cons_list"><a href="#val-cons_list" class="anchor"></a><code><span class="keyword">val</span> cons_list : <span class="type-var">'error</span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span></code></dt><dd><p><code>cons_list error errors</code> is the sequential composition of all the errors passed as parameters. It is equivalent to folding <code>cons</code> over <code>List.rev error :: errors</code> but more efficient.</p><p>Note that <code>error</code> and <code>errors</code> are separated as parameters to enforce that empty traces cannot be constructed. The recommended use is:</p><pre><code class="ml">match all_errors with
| [] -&gt; Ok () (* or something else depending on the context *)
| error :: errors -&gt; Error (cons_list error errors)</code></pre><p>When you are within the error monad itself, you should build traces using the <code>record_trace</code>, <code>trace</code>, <code>record_trace_eval</code> and <code>trace_eval</code> functions directly. You should rarely need to build traces manually using <code>cons_list</code>. This here function can be useful in the case where you are at the interface of the error monad.</p></dd></dl><dl><dt class="spec value" id="val-conp"><a href="#val-conp" class="anchor"></a><code><span class="keyword">val</span> conp : <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span></code></dt><dd><p><code>conp t1 t2</code> (construct parallel) construct a parallel trace. This is for tracing events/failure/things that happen concurrently, in parallel, or simply independently of each other. E.g.,</p><p><code>let fetch_density () =
         let area = fetch_area () in
         let population = fetch_population () in
         match area, population with
         | Ok area, Ok population -&gt; Ok (population / area)
         | Error trace, Ok _ | Ok _, Error trace -&gt; Error trace
         | Error trace1, Error trace2 -&gt; Error (conp trace1 trace2)
      </code></p><p>When you are within the error monad itself, you should rarely need to build traces manually using <code>conp</code>. The result-concurrent traversors will return parallel traces when appropriate, and so will <code>join_e</code>, <code>join_ep</code>, <code>both_e</code>, <code>both_ep</code>, <code>all_e</code> and <code>all_ep</code>.</p></dd></dl><dl><dt class="spec value" id="val-conp_list"><a href="#val-conp_list" class="anchor"></a><code><span class="keyword">val</span> conp_list : <span><span class="type-var">'err</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'err</span> <a href="index.html#type-trace">trace</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'err</span> <a href="index.html#type-trace">trace</a></span></code></dt><dd><p><code>conp_list trace traces</code> is the parallel composition of all the traces passed as parameters. It is equivalent to <code>List.fold_left conp trace traces</code> but more efficient.</p><p>Note that <code>trace</code> and <code>traces</code> are separated as parameters to enforce that empty traces cannot be constructed. The recommended use is:</p><pre><code class="ml">match all_traces with
| [] -&gt; Ok () (* or something else depending on the context *)
| trace :: traces -&gt; Error (conp_list trace traces)</code></pre><p>When you are within the error monad itself, you should rarely need to build traces manually using <code>conp</code>. The result-concurrent traversors will return parallel traces when appropriate, and so will <code>join_e</code>, <code>join_ep</code>, <code>both_e</code>, <code>both_ep</code>, <code>all_e</code> and <code>all_ep</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_print"><a href="#val-pp_print" class="anchor"></a><code><span class="keyword">val</span> pp_print : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'err</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'err</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_print</code> pretty-prints a trace of errors</p></dd></dl><dl><dt class="spec value" id="val-pp_print_top"><a href="#val-pp_print_top" class="anchor"></a><code><span class="keyword">val</span> pp_print_top : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'err</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'err</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_print_top</code> pretty-prints the top errors of the trace</p></dd></dl><dl><dt class="spec value" id="val-encoding"><a href="#val-encoding" class="anchor"></a><code><span class="keyword">val</span> encoding : <span><span class="type-var">'error</span> Data_encoding.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span> Data_encoding.t</span></code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'error</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'error</span> <a href="index.html#type-trace">trace</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f init trace</code> traverses the trace (in an unspecified manner) so that <code>init</code> is folded over each of the error within <code>trace</code> by <code>f</code>. Typical use is to find the worst error, to check for the presence of a given error, etc.</p></dd></dl></div></body></html>