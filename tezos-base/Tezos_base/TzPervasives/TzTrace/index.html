<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TzTrace (tezos-base.Tezos_base.TzPervasives.TzTrace)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">tezos-base</a> &#x00BB; <a href="../../index.html">Tezos_base</a> &#x00BB; <a href="../index.html">TzPervasives</a> &#x00BB; TzTrace</nav><header class="odoc-preamble"><h1>Module <code><span>TzPervasives.TzTrace</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-trace" class="anchored"><a href="#type-trace" class="anchor"></a><code><span><span class="keyword">type</span> <span>'error trace</span></span><span> = <span><span class="type-var">'error</span> list</span></span></code></div><div class="spec-doc"><p><code>trace</code> is abstract in this interface but it is made concrete in the instantiated error monad (see <code>error_monad.mli</code>).</p><p>The idea of abstracting the trace is so that it can evolve more easily. Eventually, we can make the trace abstract in the instantiated error monad, we can have different notions of traces for the protocol and the shell, etc.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span class="type-var">'error</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span></span></code></div><div class="spec-doc"><p><code>make e</code> makes a singleton trace, the simplest of traces that carries a single error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'error</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span></span></code></div><div class="spec-doc"><p><code>cons e t</code> (construct sequential) constructs a sequential trace. This is for tracing events/failures/things that happen one after the other, generally one as a consequence of the other. E.g.,</p><p><code>let file_handle =
         match attempt_open name with
         | Ok handle -&gt; Ok handle
         | Error error -&gt;
               let trace = make error in
               match attempt_create name with
               | Ok handle -&gt; Ok handle
               | Error error -&gt; Error (cons error trace)
      </code></p><p>When you are within the error monad itself, you should build traces using the <code>record_trace</code>, <code>trace</code>, <code>record_trace_eval</code> and <code>trace_eval</code> functions directly. You should rarely need to build traces manually using <code>cons</code>. This here function can be useful in the case where you are at the interface of the error monad.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons_list" class="anchored"><a href="#val-cons_list" class="anchor"></a><code><span><span class="keyword">val</span> cons_list : <span><span class="type-var">'error</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'error</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span></span></code></div><div class="spec-doc"><p><code>cons_list error errors</code> is the sequential composition of all the errors passed as parameters. It is equivalent to folding <code>cons</code> over <code>List.rev error :: errors</code> but more efficient.</p><p>Note that <code>error</code> and <code>errors</code> are separated as parameters to enforce that empty traces cannot be constructed. The recommended use is:</p><pre><code>match all_errors with
| [] -&gt; Ok () (* or something else depending on the context *)
| error :: errors -&gt; Error (cons_list error errors)</code></pre><p>When you are within the error monad itself, you should build traces using the <code>record_trace</code>, <code>trace</code>, <code>record_trace_eval</code> and <code>trace_eval</code> functions directly. You should rarely need to build traces manually using <code>cons_list</code>. This here function can be useful in the case where you are at the interface of the error monad.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-conp" class="anchored"><a href="#val-conp" class="anchor"></a><code><span><span class="keyword">val</span> conp : <span><span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span></span></code></div><div class="spec-doc"><p><code>conp t1 t2</code> (construct parallel) construct a parallel trace. This is for tracing events/failure/things that happen concurrently, in parallel, or simply independently of each other. E.g.,</p><p><code>let fetch_density () =
         let area = fetch_area () in
         let population = fetch_population () in
         match area, population with
         | Ok area, Ok population -&gt; Ok (population / area)
         | Error trace, Ok _ | Ok _, Error trace -&gt; Error trace
         | Error trace1, Error trace2 -&gt; Error (conp trace1 trace2)
      </code></p><p>When you are within the error monad itself, you should rarely need to build traces manually using <code>conp</code>. The result-concurrent traversors will return parallel traces when appropriate, and so will <code>join_e</code>, <code>join_ep</code>, <code>both_e</code>, <code>both_ep</code>, <code>all_e</code> and <code>all_ep</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-conp_list" class="anchored"><a href="#val-conp_list" class="anchor"></a><code><span><span class="keyword">val</span> conp_list : <span><span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span></span></code></div><div class="spec-doc"><p><code>conp_list trace traces</code> is the parallel composition of all the traces passed as parameters. It is equivalent to <code>List.fold_left conp trace traces</code> but more efficient.</p><p>Note that <code>trace</code> and <code>traces</code> are separated as parameters to enforce that empty traces cannot be constructed. The recommended use is:</p><pre><code>match all_traces with
| [] -&gt; Ok () (* or something else depending on the context *)
| trace :: traces -&gt; Error (conp_list trace traces)</code></pre><p>When you are within the error monad itself, you should rarely need to build traces manually using <code>conp</code>. The result-concurrent traversors will return parallel traces when appropriate, and so will <code>join_e</code>, <code>join_ep</code>, <code>both_e</code>, <code>both_ep</code>, <code>all_e</code> and <code>all_ep</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_print" class="anchored"><a href="#val-pp_print" class="anchor"></a><code><span><span class="keyword">val</span> pp_print : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_print</code> pretty-prints a trace of errors</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_print_top" class="anchored"><a href="#val-pp_print_top" class="anchor"></a><code><span><span class="keyword">val</span> pp_print_top : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_print_top</code> pretty-prints the top errors of the trace</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encoding" class="anchored"><a href="#val-encoding" class="anchor"></a><code><span><span class="keyword">val</span> encoding : <span><span><span class="type-var">'error</span> <span class="xref-unresolved">Data_encoding</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span> <span class="xref-unresolved">Data_encoding</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'error</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold f init trace</code> traverses the trace (in an unspecified manner) so that <code>init</code> is folded over each of the error within <code>trace</code> by <code>f</code>. Typical use is to find the worst error, to check for the presence of a given error, etc.</p></div></div></div></body></html>