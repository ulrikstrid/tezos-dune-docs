<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_utils (tezos-base.Tezos_base__TzPervasives.Lwt_utils)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">tezos-base</a> &#x00BB; <a href="../index.html">Tezos_base__TzPervasives</a> &#x00BB; Lwt_utils</nav><h1>Module <code>Tezos_base__TzPervasives.Lwt_utils</code></h1></header><dl><dt class="spec value" id="val-never_ending"><a href="#val-never_ending" class="anchor"></a><code><span class="keyword">val</span> never_ending : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span></code></dt><dt class="spec value" id="val-worker"><a href="#val-worker" class="anchor"></a><code><span class="keyword">val</span> worker : string <span>&#45;&gt;</span> <span>on_event:<span>(string <span>&#45;&gt;</span> <span>[ `Ended <span><span>| `Failed</span> of string</span> <span>| `Started</span> ]</span> <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <span>run:<span>(unit <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <span>cancel:<span>(unit <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>worker name ~on_event ~run ~cancel</code> internally calls <code>run ()</code> (which returns a promise <code>p</code>) and returns its own promise <code>work</code>. If <code>p</code> becomes fulfilled, then <code>work</code> also becomes fulfilled. If <code>p</code> becomes rejected then <code>cancel ()</code> is called and, once its promise is resolved, <code>work</code> is fulfilled. This gives the opportunity for the function <code>cancel</code> to clean-up some resources.</p><p>The function <code>on_event</code> is called at different times (start, failure, end) and is mostly meant as a logging mechanism but can also be used for other purposes such as synchronization between different workers.</p><p>If the promises returned by <code>on_event</code> or <code>cancel</code> raise an exception or become rejected, the exception/failure is simply ignored and the promise is treated as having resolved anyway.</p><p>Note that the promise <code>work</code> returned by the <code>worker</code> function is not cancelable. If you need to cancel the promise returned by <code>run</code>, you need to embed your own synchronization system within <code>run</code>. E.g.,</p><p><code>let p, r = Lwt.wait in
     let run () =
        let main = … in
        Lwt.pick [main ; p]
     in</code></p></dd></dl><dl><dt class="spec value" id="val-fold_left_s_n"><a href="#val-fold_left_s_n" class="anchor"></a><code><span class="keyword">val</span> fold_left_s_n : <span>n:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> Lwt.t</span></code></dt><dd><p>Evaluates fold_left_s on a batch of <code>n</code> elements and returns a pair containing the result of the first batch and the unprocessed elements</p></dd></dl><dl><dt class="spec value" id="val-dont_wait"><a href="#val-dont_wait" class="anchor"></a><code><span class="keyword">val</span> dont_wait : <span>(exn <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dont_wait handler f</code> calls <code>f ()</code> and essentially ignores the returned promise. In particular it does not wait for the promise to resolve.</p><p><code>dont_wait</code> is meant as an alternative to <code>Lwt.async</code>. The former requires an explicit, local exception handler whereas the latter uses a global handler that is set by side-effects.</p><p>CAVEAT!</p><p>Note that, because of the semantics of execution in Lwt, the evaluation of <code>f ()</code> is immediate and some progress towards the resolution of the promise may happen immediately. Specifically, the progress towards the resolution of the promise <code>p</code> returned by <code>f ()</code> is made until the point where it yields. At that point, control comes back to the caller of <code>dont_wait</code> and continues. More concretely, consider the order of the side-effects in the following piece of code and in particular how the second side-effect in the order of execution is within the promise created by <code>dont_wait</code>.</p><p><code>side_effect (); (* first *)
     dont_wait
       (fun exc -&gt; ..)
       (fun () -&gt;
          side_effect (); (* second *)
          Lwt.pause () &gt;&gt;= fun () -&gt;
          side_effect (); (* delayed *)
          ..);
     side_effect (); (* third *)
    </code></p><p>If you want to delay any progress towards promise resolution being made (e.g., if you need strong guarantees about side-effects because you are in a critical section), then you need to add an explicit cooperation point. You can use <code>Lwt.pause</code> at the very beginning of the promise you pass to <code>dont_wait</code>: <code>dont_wait handler (fun () -&gt; Lwt.pause () &gt;&gt;= fun () -&gt; ..)</code>.</p><p>With this pattern, in the expression <code>dont_wait handler (fun () -&gt; Lwt.pause () &gt;&gt;= f)</code>, the anonymous lambda (<code>(fun () -&gt; …)</code>) is called immediately. However, when this call is evaluated, the call to <code>pause</code> immediately suspend progress towards the resolution of the promise, delaying the call <code>f ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_map_s"><a href="#val-find_map_s" class="anchor"></a><code><span class="keyword">val</span> find_map_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> option</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> option</span> Lwt.t</span></code></dt><dd><p>Lwt version of <code>TzList.find_map</code></p></dd></dl></div></body></html>