<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Circular_buffer (tezos-base.Tezos_base__TzPervasives.Circular_buffer)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-base</a> &#x00BB; <a href="../index.html">Tezos_base__TzPervasives</a> &#x00BB; Circular_buffer</nav><h1>Module <code>Tezos_base__TzPervasives.Circular_buffer</code></h1></header><aside><p>This module implements a bufferisation abstraction to store temporary raw data chunks (as bytes) when chunks are read sequentially. The function write allows to store chunks in the buffer and the function read to read them from the buffer.</p><p>The global contract is that if we write consecutively <code>d1;d2</code> onto the buffer. Then we have to fully read d1 and d2, in that order.</p><p>This contract is not enforced by the library, it is the user responsability to respect it.</p><p>If the circular buffer is full, a new temporary buffer is allocated to store the chunk of data to be written.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Type of circular buffers</p></dd></dl><dl><dt class="spec type" id="type-data"><a href="#type-data" class="anchor"></a><code><span class="keyword">type</span> data</code></dt><dd><p>An abstraction over a chunk of data written in the buffer.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;maxlength:int</span> <span>&#45;&gt;</span> <span>?&#8288;fresh_buf_size:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a buffer of size maxlength. If the buffer is full, a buffer of size <code>fresh_buf_size</code> is allocated (by default `2` kb).</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span>maxlen:int</span> <span>&#45;&gt;</span> <span>fill_using:<span>(Stdlib.Bytes.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-data">data</a> Lwt.t</span></code></dt><dd><p><code>write ~maxlen ~fill_using:f buffer</code> calls <code>fill_using buf offset
   maxlen</code> where <code>buf</code> is a buffer that has room for <code>maxlen</code> data starting from <code>offset</code>.</p><p>Assumes that <code>fill_using</code> returns the exact amount of written bytes.</p><p>Behaviour is unspecified if <code>fill_using</code> writes more than <code>maxlen</code> data or lies on the number of written bytes.</p><p>It returns a data descriptor for the supposedly written chunk.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-data">data</a> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>into:Stdlib.Bytes.t</span> <span>&#45;&gt;</span> <span>offset:int</span> <span>&#45;&gt;</span> <span><a href="index.html#type-data">data</a> option</span></code></dt><dd><p><code>read data ~len ~into:buf buffer ~offset</code> blit <code>len</code> data from the <code>data</code> chunk. If <code>len</code> is not provided, blit all the data. If <code>len</code> is less than the amount of data available, it returns a new handler the the remainder.</p><p>Assumes that data has been produce by a write attempt in <code>buffer</code>. Assumes that ~len is lesser than <code>length data</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-data">data</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length data</code> returns the amount of avalaible bytes in <code>data</code></p></dd></dl></div></body></html>