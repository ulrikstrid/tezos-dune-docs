<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt (tezos-protocol-functor-alpha.Tezos_protocol_alpha_functor__Functor.Make.1-Tezos_protocol_environment.Lwt)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../../index.html">tezos-protocol-functor-alpha</a> &#x00BB; <a href="../../../index.html">Tezos_protocol_alpha_functor__Functor</a> &#x00BB; <a href="../../index.html">Make</a> &#x00BB; <a href="../index.html">1-Tezos_protocol_environment</a> &#x00BB; Lwt</nav><h1>Module <code>1-Tezos_protocol_environment.Lwt</code></h1><nav class="toc"><ul><li><a href="#fundamentals">Fundamentals</a><ul><li><a href="#promises">Promises</a></li><li><a href="#callbacks">Callbacks</a></li></ul></li><li><a href="#convenience">Convenience</a><ul><li><a href="#callback-helpers">Callback helpers</a></li><li><a href="#pre-allocated-promises">Pre-allocated promises</a></li></ul></li></ul></nav></header><section><header><h3 id="fundamentals"><a href="#fundamentals" class="anchor"></a>Fundamentals</h3></header><section><header><h4 id="promises"><a href="#promises" class="anchor"></a>Promises</h4></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code></dt><dd><p>Promises for values of type <code>'a</code>.</p><p>A <b>promise</b> is a memory cell that is always in one of three <b>states</b>:</p><ul><li><em>fulfilled</em>, and containing one value of type <code>'a</code>,</li><li><em>rejected</em>, and containing one exception, or</li><li><em>pending</em>, in which case it may become fulfilled or rejected later.</li></ul><p>A <em>resolved</em> promise is one that is either fulfilled or rejected, i.e. not pending. Once a promise is resolved, its content cannot change. So, promises are <em>write-once references</em>. The only possible state changes are (1) from pending to fulfilled and (2) from pending to rejected.</p><p>Promises are typically “read” by attaching <b>callbacks</b> to them. The most basic functions for that are <a href="index.html#val-bind"><code>Lwt.bind</code></a>, which attaches a callback that is called when a promise becomes fulfilled, and <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.catch&quot;"><a href="../index.html#module-Lwt"><code>Lwt</code></a>.catch</span>, for rejection.</p><p>Promise variables of this type, <code>'a Lwt.t</code>, are actually <b>read-only</b> in Lwt. Separate <em>resolvers</em> of type <code>'a </code><span class="xref-unresolved" title="unresolved reference to &quot;Lwt.u&quot;"><a href="../index.html#module-Lwt"><code>Lwt</code></a>.u</span> are used to write to them. Promises and their resolvers are created together by calling <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.wait&quot;"><a href="../index.html#module-Lwt"><code>Lwt</code></a>.wait</span>. There is one exception to this: most promises can be <em>canceled</em> by calling <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.cancel&quot;"><a href="../index.html#module-Lwt"><code>Lwt</code></a>.cancel</span>, without going through a resolver.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return v</code> creates a new <a href="#TYPEt">promise</a> that is <em>already fulfilled</em> with value <code>v</code>.</p><p>This is needed to satisfy the type system in some cases. For example, in a <code>match</code> expression where one case evaluates to a promise, the other cases have to evaluate to promises as well:</p><pre><code class="ml">match need_input with
| true -&gt; Lwt_io.(read_line stdin)   (* Has type string Lwt.t... *)
| false -&gt; Lwt.return &quot;&quot;             (* ...so wrap empty string in a promise. *)</code></pre><p>Another typical usage is in <a href="#VALbind"><code>let%lwt</code></a>. The expression after the “<code>in</code>” has to evaluate to a promise. So, if you compute an ordinary value instead, you have to wrap it:</p><pre><code class="ml">let%lwt line = Lwt_io.(read_line stdin) in
Lwt.return (line ^ &quot;.&quot;)</code></pre></dd></dl></section><section><header><h4 id="callbacks"><a href="#callbacks" class="anchor"></a>Callbacks</h4></header><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.bind p_1 f</code> makes it so that <code>f</code> will run when <code>p_1</code> is <a href="#TYPEt"><em>fulfilled</em></a>.</p><p>When <code>p_1</code> is fulfilled with value <code>v_1</code>, the callback <code>f</code> is called with that same value <code>v_1</code>. Eventually, after perhaps starting some I/O or other computation, <code>f</code> returns promise <code>p_2</code>.</p><p><code>Lwt.bind</code> itself returns immediately. It only attaches the callback <code>f</code> to <code>p_1</code> – it does not wait for <code>p_2</code>. <em>What</em> <code>Lwt.bind</code> returns is yet a third promise, <code>p_3</code>. Roughly speaking, fulfillment of <code>p_3</code> represents both <code>p_1</code> and <code>p_2</code> becoming fulfilled, one after the other.</p><p>A minimal example of this is an echo program:</p><pre><code class="ml">let () =
  let p_3 =
    Lwt.bind
      Lwt_io.(read_line stdin)
      (fun line -&gt; Lwt_io.printl line)
  in
  Lwt_main.run p_3

(* ocamlfind opt -linkpkg -thread -package lwt.unix code.ml &amp;&amp; ./a.out *)</code></pre><p>Rejection of <code>p_1</code> and <code>p_2</code>, and raising an exception in <code>f</code>, are all forwarded to rejection of <code>p_3</code>.</p><p><b>Precise behavior</b></p><p><code>Lwt.bind</code> returns a promise <code>p_3</code> immediately. <code>p_3</code> starts out pending, and is resolved as follows:</p><ul><li>The first condition to wait for is that <code>p_1</code> becomes resolved. It does not matter whether <code>p_1</code> is already resolved when <code>Lwt.bind</code> is called, or becomes resolved later – the rest of the behavior is the same.</li><li>If and when <code>p_1</code> becomes resolved, it will, by definition, be either fulfilled or rejected.</li><li>If <code>p_1</code> is rejected, <code>p_3</code> is rejected with the same exception.</li><li>If <code>p_1</code> is fulfilled, with value <code>v</code>, <code>f</code> is applied to <code>v</code>.</li><li><code>f</code> may finish by returning the promise <code>p_2</code>, or raising an exception.</li><li>If <code>f</code> raises an exception, <code>p_3</code> is rejected with that exception.</li><li>Finally, the remaining case is when <code>f</code> returns <code>p_2</code>. From that point on, <code>p_3</code> is effectively made into a reference to <code>p_2</code>. This means they have the same state, undergo the same state changes, and performing any operation on one is equivalent to performing it on the other.</li></ul><p><b>Syntactic sugar</b></p><p><code>Lwt.bind</code> is almost never written directly, because sequences of <code>Lwt.bind</code> result in growing indentation and many parentheses:</p><pre><code class="ml">let () =
  Lwt_main.run begin
    Lwt.bind Lwt_io.(read_line stdin) (fun line -&gt;
      Lwt.bind (Lwt_unix.sleep 1.) (fun () -&gt;
        Lwt_io.printf &quot;One second ago, you entered %s\n&quot; line))
  end

(* ocamlfind opt -linkpkg -thread -package lwt.unix code.ml &amp;&amp; ./a.out *)</code></pre><p>The recommended way to write <code>Lwt.bind</code> is using the <code>let%lwt</code> syntactic sugar:</p><pre><code class="ml">let () =
  Lwt_main.run begin
    let%lwt line = Lwt_io.(read_line stdin) in
    let%lwt () = Lwt_unix.sleep 1. in
    Lwt_io.printf &quot;One second ago, you entered %s\n&quot; line
  end

(* ocamlfind opt -linkpkg -thread -package lwt_ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</code></pre><p>This uses the Lwt <a href="Ppx_lwt.html">PPX</a> (preprocessor). Note that we had to add package <code>lwt_ppx</code> to the command line for building this program. We will do that throughout this manual.</p><p>Another way to write <code>Lwt.bind</code>, that you may encounter while reading code, is with the <code>&gt;&gt;=</code> operator:</p><pre><code class="ml">open Lwt.Infix

let () =
  Lwt_main.run begin
    Lwt_io.(read_line stdin) &gt;&gt;= fun line -&gt;
    Lwt_unix.sleep 1. &gt;&gt;= fun () -&gt;
    Lwt_io.printf &quot;One second ago, you entered %s\n&quot; line
  end

(* ocamlfind opt -linkpkg -thread -package lwt.unix code.ml &amp;&amp; ./a.out *)</code></pre><p>The <code>&gt;&gt;=</code> operator comes from the module <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.Infix&quot;"><a href="../index.html#module-Lwt"><code>Lwt</code></a>.Infix</span>, which is why we opened it at the beginning of the program.</p><p>See also <a href="index.html#val-map"><code>Lwt.map</code></a>.</p></dd></dl></section></section><section><header><h3 id="convenience"><a href="#convenience" class="anchor"></a>Convenience</h3></header><section><header><h4 id="callback-helpers"><a href="#callback-helpers" class="anchor"></a>Callback helpers</h4></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.map f p_1</code> is similar to <a href="index.html#val-bind"><code>Lwt.bind</code></a><code> p_1 f</code>, but <code>f</code> is not expected to return a promise.</p><p>This function is more convenient that <a href="index.html#val-bind"><code>Lwt.bind</code></a> when <code>f</code> inherently does not return a promise. An example is <code>Stdlib.int_of_string</code>:</p><pre><code class="ml">let read_int : unit -&gt; int Lwt.t = fun () -&gt;
  Lwt.map
    int_of_string
    Lwt_io.(read_line stdin)

let () =
  Lwt_main.run begin
    let%lwt number = read_int () in
    Lwt_io.printf &quot;%i\n&quot; number
  end

(* ocamlfind opt -linkpkg -thread -package lwt_ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</code></pre><p>By comparison, the <a href="index.html#val-bind"><code>Lwt.bind</code></a> version is more awkward:</p><pre><code class="ml">let read_int : unit -&gt; int Lwt.t = fun () -&gt;
  Lwt.bind
    Lwt_io.(read_line stdin)
    (fun line -&gt; Lwt.return (int_of_string line))</code></pre><p>As with <a href="index.html#val-bind"><code>Lwt.bind</code></a>, sequences of calls to <code>Lwt.map</code> result in excessive indentation and parentheses. The recommended syntactic sugar for avoiding this is the <a href="#VAL(&gt;|=)"><code>&gt;|=</code></a> operator, which comes from module <code>Lwt.Infix</code>:</p><pre><code class="ml">open Lwt.Infix

let read_int : unit -&gt; int Lwt.t = fun () -&gt;
  Lwt_io.(read_line stdin) &gt;|= int_of_string</code></pre><p>The detailed operation follows. For consistency with the promises in <a href="index.html#val-bind"><code>Lwt.bind</code></a>, the <em>two</em> promises involved are named <code>p_1</code> and <code>p_3</code>:</p><ul><li><code>p_1</code> is the promise passed to <code>Lwt.map</code>.</li><li><code>p_3</code> is the promise returned by <code>Lwt.map</code>.</li></ul><p><code>Lwt.map</code> returns a promise <code>p_3</code>. <code>p_3</code> starts out pending. It is resolved as follows:</p><ul><li><code>p_1</code> may be, or become, resolved. In that case, by definition, it will become fulfilled or rejected. Fulfillment is the interesting case, but the behavior on rejection is simpler, so we focus on rejection first.</li><li>When <code>p_1</code> becomes rejected, <code>p_3</code> is rejected with the same exception.</li><li>When <code>p_1</code> instead becomes fulfilled, call the value it is fulfilled with <code>v</code>.</li><li><code>f v</code> is applied. If this finishes, it may either return another value, or raise an exception.</li><li>If <code>f v</code> returns another value <code>v'</code>, <code>p_3</code> is fulfilled with <code>v'</code>.</li><li>If <code>f v</code> raises exception <code>exn</code>, <code>p_3</code> is rejected with <code>exn</code>.</li></ul></dd></dl></section><section><header><h4 id="pre-allocated-promises"><a href="#pre-allocated-promises" class="anchor"></a>Pre-allocated promises</h4></header><dl><dt class="spec value" id="val-return_unit"><a href="#val-return_unit" class="anchor"></a><code><span class="keyword">val</span> return_unit : <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return_unit</code> is defined as <a href="index.html#val-return"><code>Lwt.return</code></a><code> ()</code>, but this definition is evaluated only once, during initialization of module <code>Lwt</code>, at the beginning of your program.</p><p>This means the promise is allocated only once. By contrast, each time <a href="index.html#val-return"><code>Lwt.return</code></a><code> ()</code> is evaluated, it allocates a new promise.</p><p>It is recommended to use <code>Lwt.return_unit</code> only where you know the allocations caused by an instance of <a href="index.html#val-return"><code>Lwt.return</code></a><code> ()</code> are a performance bottleneck. Generally, the cost of I/O tends to dominate the cost of <a href="index.html#val-return"><code>Lwt.return</code></a><code> ()</code> anyway.</p><p>In future Lwt, we hope to perform this optimization, of using a single, pre-allocated promise, automatically, wherever <a href="index.html#val-return"><code>Lwt.return</code></a><code> ()</code> is written.</p></dd></dl><dl><dt class="spec value" id="val-return_none"><a href="#val-return_none" class="anchor"></a><code><span class="keyword">val</span> return_none : <span><span><span class="type-var">_</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return_none</code> is like <a href="index.html#val-return_unit"><code>Lwt.return_unit</code></a>, but for <a href="index.html#val-return"><code>Lwt.return</code></a><code> None</code>.</p></dd></dl><dl><dt class="spec value" id="val-return_nil"><a href="#val-return_nil" class="anchor"></a><code><span class="keyword">val</span> return_nil : <span><span><span class="type-var">_</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return_nil</code> is like <a href="index.html#val-return_unit"><code>Lwt.return_unit</code></a>, but for <a href="index.html#val-return"><code>Lwt.return</code></a><code> []</code>.</p></dd></dl><dl><dt class="spec value" id="val-return_true"><a href="#val-return_true" class="anchor"></a><code><span class="keyword">val</span> return_true : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return_true</code> is like <a href="index.html#val-return_unit"><code>Lwt.return_unit</code></a>, but for <a href="index.html#val-return"><code>Lwt.return</code></a><code> true</code>.</p></dd></dl><dl><dt class="spec value" id="val-return_false"><a href="#val-return_false" class="anchor"></a><code><span class="keyword">val</span> return_false : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Lwt.return_false</code> is like <a href="index.html#val-return_unit"><code>Lwt.return_unit</code></a>, but for <a href="index.html#val-return"><code>Lwt.return</code></a><code> false</code>.</p></dd></dl></section></section></div></body></html>