<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Timelock (tezos-crypto.Tezos_crypto.Timelock)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-crypto</a> &#x00BB; <a href="../index.html">Tezos_crypto</a> &#x00BB; Timelock</nav><h1>Module <code>Tezos_crypto.Timelock</code></h1></header><aside><p><code>Timelock</code> is a set of functions to handle time-locking a value and opening time-locked values.</p><p>A time-locked value can either be opened quickly by the locker itself (i.e., the one possessing the RSA secret), or slowly by anyone doing a fixed number of sequential operations.</p><p>In the interface of this module, this fixed number is consistently named <code>time</code> and is always represented by an arbitrary precision integer <code>Z.t</code>.</p><p>Once opened via the slow method a proof of opening can be produced to avoid having to do so again. This proof is verifiable in logarithmic time.</p><p>In order to time-lock an arbitrary sequence of bytes, we 1. encrypt the bytes with a symmetric key, and then 2. we time-lock the symmetric key itself.</p><p>This module implements a scheme inspired by: Time-lock puzzles and timed release - Rivest, Shamir, Wagner https://people.csail.mit.edu/rivest/pubs/RSW96.pdf</p></aside><aside><p>!!! WARNING !!!</p><p>WE USE 2048 RSA KEYS WHICH DO NOT PROVIDE THE CLASSICAL 128 BITS OF SECURITY. WE ALLOW OURSELVES TO DO THAT SINCE WE DO NOT EXPOSE KEYS FOR A LONG TIME. YOU ARE RESPONSIBLE FOR NOT REUSING OLD KEYS</p></aside><dl><dt class="spec type" id="type-symmetric_key"><a href="#type-symmetric_key" class="anchor"></a><code><span class="keyword">type</span> symmetric_key</code></dt><dd><p>We will time-lock symmetric keys to then handle arbitrary bytes</p></dd></dl><dl><dt class="spec type" id="type-rsa_public"><a href="#type-rsa_public" class="anchor"></a><code><span class="keyword">type</span> rsa_public</code></dt><dd><p>RSA public key to define a group in which we will work. The key is an integer n = p*q with p,q primes number. The group we work in is the set of inversible mod n.</p></dd></dl><dl><dt class="spec type" id="type-rsa_secret"><a href="#type-rsa_secret" class="anchor"></a><code><span class="keyword">type</span> rsa_secret</code></dt><dd><p>RSA secret key of the from p,q. Indicates the cardinal of the group.</p></dd></dl><dl><dt class="spec type" id="type-time_lock_proof"><a href="#type-time_lock_proof" class="anchor"></a><code><span class="keyword">type</span> time_lock_proof</code></dt><dd><p>Proof that the opening of a value is the claimed value. Is concretely a member of the RSA group.</p></dd></dl><dl><dt class="spec type" id="type-locked_value"><a href="#type-locked_value" class="anchor"></a><code><span class="keyword">type</span> locked_value</code></dt><dd><p>Locked value that can be quickly access with a secret or slowly-access with a number of sequential operations. Is concretely a member of the RSA group.</p></dd></dl><dl><dt class="spec type" id="type-unlocked_value"><a href="#type-unlocked_value" class="anchor"></a><code><span class="keyword">type</span> unlocked_value</code></dt><dd><p>Member of the RSA group that we will lock. In our case it represents a symmetric key.</p></dd></dl><dl><dt class="spec type" id="type-ciphertext"><a href="#type-ciphertext" class="anchor"></a><code><span class="keyword">type</span> ciphertext</code></dt><dd><p>A symmetric ciphertext and message authentication code, containing the bytes we want to protect</p></dd></dl><dl><dt class="spec value" id="val-gen_rsa_keys"><a href="#val-gen_rsa_keys" class="anchor"></a><code><span class="keyword">val</span> gen_rsa_keys : unit <span>&#45;&gt;</span> <a href="index.html#type-rsa_public">rsa_public</a> * <a href="index.html#type-rsa_secret">rsa_secret</a></code></dt><dd><p>Generates random RSA keys of 2046 bits. The size works only if we use them for a small amount of time. !!! NEW KEYS SHOULD BE GENERATED FOR EACH LOCKING !!!</p><dl><dt>raises [Failure]</dt><dd><p>if there is not enough entropy available.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gen_locked_value"><a href="#val-gen_locked_value" class="anchor"></a><code><span class="keyword">val</span> gen_locked_value : <a href="index.html#type-rsa_public">rsa_public</a> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a></code></dt><dd><p>Generates almost uniformly an integer mod n. It is in the RSA group with overwhelming probability. We use this since we want to lock symmetric keys, not pre-determined messages.</p><dl><dt>raises [Failure]</dt><dd><p>if there is not enough entropy available.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unlocked_value_to_symmetric_key"><a href="#val-unlocked_value_to_symmetric_key" class="anchor"></a><code><span class="keyword">val</span> unlocked_value_to_symmetric_key : <a href="index.html#type-unlocked_value">unlocked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-symmetric_key">symmetric_key</a></code></dt><dd><p>Hashes a number mod n to a symmetric key for authenticated encryption.</p></dd></dl><dl><dt class="spec value" id="val-locked_value_to_symmetric_key_with_secret"><a href="#val-locked_value_to_symmetric_key_with_secret" class="anchor"></a><code><span class="keyword">val</span> locked_value_to_symmetric_key_with_secret : <a href="index.html#type-rsa_secret">rsa_secret</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-symmetric_key">symmetric_key</a></code></dt><dd><p>Unlock a value using RSA secret and hash the result to derive a symmetric key using <code>unlocked_value_to_symmetric_key</code></p></dd></dl><dl><dt class="spec value" id="val-unlock_with_secret"><a href="#val-unlock_with_secret" class="anchor"></a><code><span class="keyword">val</span> unlock_with_secret : <a href="index.html#type-rsa_secret">rsa_secret</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a></code></dt><dd><p>Unlock a value using the RSA secret.</p></dd></dl><dl><dt class="spec value" id="val-unlock_and_prove_with_secret"><a href="#val-unlock_and_prove_with_secret" class="anchor"></a><code><span class="keyword">val</span> unlock_and_prove_with_secret : <a href="index.html#type-rsa_secret">rsa_secret</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> * <a href="index.html#type-time_lock_proof">time_lock_proof</a></code></dt><dd><p>Unlock a value using the RSA secret. Also produces a proof certifying that the result is indeed what had been locked.</p></dd></dl><dl><dt class="spec value" id="val-unlock_and_prove_without_secret"><a href="#val-unlock_and_prove_without_secret" class="anchor"></a><code><span class="keyword">val</span> unlock_and_prove_without_secret : <a href="index.html#type-rsa_public">rsa_public</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> * <a href="index.html#type-time_lock_proof">time_lock_proof</a></code></dt><dd><p>Unlock a value the slow way, without the RSA secret. Also produces a proof certifying that the result is indeed what had been locked.</p></dd></dl><dl><dt class="spec value" id="val-prove_without_secret"><a href="#val-prove_without_secret" class="anchor"></a><code><span class="keyword">val</span> prove_without_secret : <a href="index.html#type-rsa_public">rsa_public</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-time_lock_proof">time_lock_proof</a></code></dt><dt class="spec value" id="val-prove_with_secret"><a href="#val-prove_with_secret" class="anchor"></a><code><span class="keyword">val</span> prove_with_secret : <a href="index.html#type-rsa_secret">rsa_secret</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-time_lock_proof">time_lock_proof</a></code></dt><dt class="spec value" id="val-verify_time_lock"><a href="#val-verify_time_lock" class="anchor"></a><code><span class="keyword">val</span> verify_time_lock : <a href="index.html#type-rsa_public">rsa_public</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-time_lock_proof">time_lock_proof</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Verifies that <code>locked_value</code> indeed contains <code>unlocked_value</code> with parameters <code>rsa_public</code> and <code>time:Z.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-locked_value_to_symmetric_key_with_proof"><a href="#val-locked_value_to_symmetric_key_with_proof" class="anchor"></a><code><span class="keyword">val</span> locked_value_to_symmetric_key_with_proof : <a href="index.html#type-rsa_public">rsa_public</a> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-unlocked_value">unlocked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-locked_value">locked_value</a> <span>&#45;&gt;</span> <a href="index.html#type-time_lock_proof">time_lock_proof</a> <span>&#45;&gt;</span> <span><a href="index.html#type-symmetric_key">symmetric_key</a> option</span></code></dt><dd><p>Receives a claim opening with a proof. If the proof is valid hashes the opening using <code>unlocked_value_to_symmetric_key</code>, returns None otherwise.</p></dd></dl><dl><dt class="spec value" id="val-encrypt"><a href="#val-encrypt" class="anchor"></a><code><span class="keyword">val</span> encrypt : <a href="index.html#type-symmetric_key">symmetric_key</a> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <a href="index.html#type-ciphertext">ciphertext</a></code></dt><dd><p>encrypt using authenticated encryption, i.e. ciphertext contains a ciphertext and a message authentication code.</p></dd></dl><dl><dt class="spec value" id="val-decrypt"><a href="#val-decrypt" class="anchor"></a><code><span class="keyword">val</span> decrypt : <a href="index.html#type-symmetric_key">symmetric_key</a> <span>&#45;&gt;</span> <a href="index.html#type-ciphertext">ciphertext</a> <span>&#45;&gt;</span> <span>bytes option</span></code></dt><dd><p>Checks the message authentication code. If correct decrypt the ciphertext, otherwise returns None.</p></dd></dl><dl><dt class="spec type" id="type-chest"><a href="#type-chest" class="anchor"></a><code><span class="keyword">type</span> chest</code><code> = </code><code>{</code><table class="record"><tr id="type-chest.locked_value" class="anchored"><td class="def field"><a href="#type-chest.locked_value" class="anchor"></a><code>locked_value : <a href="index.html#type-locked_value">locked_value</a>;</code></td></tr><tr id="type-chest.time" class="anchored"><td class="def field"><a href="#type-chest.time" class="anchor"></a><code>time : Z.t;</code></td></tr><tr id="type-chest.rsa_public" class="anchored"><td class="def field"><a href="#type-chest.rsa_public" class="anchor"></a><code>rsa_public : <a href="index.html#type-rsa_public">rsa_public</a>;</code></td></tr><tr id="type-chest.ciphertext" class="anchored"><td class="def field"><a href="#type-chest.ciphertext" class="anchor"></a><code>ciphertext : <a href="index.html#type-ciphertext">ciphertext</a>;</code></td></tr></table><code>}</code></dt><dd><p>Contains a value (the decryption of the ciphertext) that can be provably recovered in <code>time</code> sequential operation or with the rsa secret.</p></dd></dl><dl><dt class="spec value" id="val-chest_encoding"><a href="#val-chest_encoding" class="anchor"></a><code><span class="keyword">val</span> chest_encoding : <span><a href="index.html#type-chest">chest</a> Data_encoding.t</span></code></dt></dl><dl><dt class="spec type" id="type-chest_key"><a href="#type-chest_key" class="anchor"></a><code><span class="keyword">type</span> chest_key</code><code> = </code><code>{</code><table class="record"><tr id="type-chest_key.unlocked_value" class="anchored"><td class="def field"><a href="#type-chest_key.unlocked_value" class="anchor"></a><code>unlocked_value : <a href="index.html#type-unlocked_value">unlocked_value</a>;</code></td></tr><tr id="type-chest_key.proof" class="anchored"><td class="def field"><a href="#type-chest_key.proof" class="anchor"></a><code>proof : <a href="index.html#type-time_lock_proof">time_lock_proof</a>;</code></td></tr></table><code>}</code></dt><dd><p>Provably opens a chest in a short time.</p></dd></dl><dl><dt class="spec value" id="val-chest_key_encoding"><a href="#val-chest_key_encoding" class="anchor"></a><code><span class="keyword">val</span> chest_key_encoding : <span><a href="index.html#type-chest_key">chest_key</a> Data_encoding.t</span></code></dt></dl><aside><p>Result of the opening of a chest. The opening can fail in two way which we distinguish to blame the right party. One can provide a false unlocked_value or unlocked_proof, in which case we return <code>Bogus_opening</code> and the provider of the chest key is at fault. Othewise, one can lock the wrong key or put garbage in the ciphertext in which case we return <code>Bogus_cipher</code> and the provider of the chest is at fault. Otherwise we return <code>Correct payload</code> where <code>payload</code> is the content that had originally been put in the chest.</p></aside><dl><dt class="spec type" id="type-opening_result"><a href="#type-opening_result" class="anchor"></a><code><span class="keyword">type</span> opening_result</code><code> = </code><table class="variant"><tr id="type-opening_result.Correct" class="anchored"><td class="def constructor"><a href="#type-opening_result.Correct" class="anchor"></a><code>| </code><code><span class="constructor">Correct</span> <span class="keyword">of</span> Stdlib.Bytes.t</code></td></tr><tr id="type-opening_result.Bogus_cipher" class="anchored"><td class="def constructor"><a href="#type-opening_result.Bogus_cipher" class="anchor"></a><code>| </code><code><span class="constructor">Bogus_cipher</span></code></td></tr><tr id="type-opening_result.Bogus_opening" class="anchored"><td class="def constructor"><a href="#type-opening_result.Bogus_opening" class="anchor"></a><code>| </code><code><span class="constructor">Bogus_opening</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-open_chest"><a href="#val-open_chest" class="anchor"></a><code><span class="keyword">val</span> open_chest : <a href="index.html#type-chest">chest</a> <span>&#45;&gt;</span> <a href="index.html#type-chest_key">chest_key</a> <span>&#45;&gt;</span> <a href="index.html#type-opening_result">opening_result</a></code></dt><dt class="spec value" id="val-create_chest_and_chest_key"><a href="#val-create_chest_and_chest_key" class="anchor"></a><code><span class="keyword">val</span> create_chest_and_chest_key : <span>payload:Stdlib.Bytes.t</span> <span>&#45;&gt;</span> <span>time:Z.t</span> <span>&#45;&gt;</span> <a href="index.html#type-chest">chest</a> * <a href="index.html#type-chest_key">chest_key</a></code></dt><dd><p>High level function which takes care of generating the locked value, the RSA parameters, and encrypt the payload. Also returns the chest key</p></dd></dl><dl><dt class="spec value" id="val-create_chest_key"><a href="#val-create_chest_key" class="anchor"></a><code><span class="keyword">val</span> create_chest_key : <a href="index.html#type-chest">chest</a> <span>&#45;&gt;</span> <a href="index.html#type-chest_key">chest_key</a></code></dt><dd><p>High level function which unlock the value and create the time-lock proof.</p></dd></dl></div></body></html>