<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Timelock (tezos-crypto.Tezos_crypto.Timelock)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-crypto</a> &#x00BB; <a href="../index.html">Tezos_crypto</a> &#x00BB; Timelock</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_crypto.Timelock</span></code></h1><p><code>Timelock</code> is a set of functions to handle time-locking a value and opening time-locked values.</p><p>A time-locked value can either be opened quickly by the locker itself (i.e., the one possessing the RSA secret), or slowly by anyone doing a fixed number of sequential operations.</p><p>In the interface of this module, this fixed number is consistently named <code>time</code> and is always represented by an arbitrary precision integer <code>Z.t</code>.</p><p>Once opened via the slow method a proof of opening can be produced to avoid having to do so again. This proof is verifiable in logarithmic time.</p><p>In order to time-lock an arbitrary sequence of bytes, we 1. encrypt the bytes with a symmetric key, and then 2. we time-lock the symmetric key itself.</p><p>This module implements a scheme inspired by: Time-lock puzzles and timed release - Rivest, Shamir, Wagner https://people.csail.mit.edu/rivest/pubs/RSW96.pdf</p></header><div class="odoc-content"><p>!!! WARNING !!!</p><p>WE USE 2048 RSA KEYS WHICH DO NOT PROVIDE THE CLASSICAL 128 BITS OF SECURITY. WE ALLOW OURSELVES TO DO THAT SINCE WE DO NOT EXPOSE KEYS FOR A LONG TIME. YOU ARE RESPONSIBLE FOR NOT REUSING OLD KEYS</p><div class="odoc-spec"><div class="spec type" id="type-symmetric_key" class="anchored"><a href="#type-symmetric_key" class="anchor"></a><code><span><span class="keyword">type</span> symmetric_key</span></code></div><div class="spec-doc"><p>We will time-lock symmetric keys to then handle arbitrary bytes</p></div></div><div class="odoc-spec"><div class="spec type" id="type-rsa_public" class="anchored"><a href="#type-rsa_public" class="anchor"></a><code><span><span class="keyword">type</span> rsa_public</span></code></div><div class="spec-doc"><p>RSA public key to define a group in which we will work. The key is an integer n = p*q with p,q primes number. The group we work in is the set of inversible mod n.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-rsa_secret" class="anchored"><a href="#type-rsa_secret" class="anchor"></a><code><span><span class="keyword">type</span> rsa_secret</span></code></div><div class="spec-doc"><p>RSA secret key of the from p,q. Indicates the cardinal of the group.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-time_lock_proof" class="anchored"><a href="#type-time_lock_proof" class="anchor"></a><code><span><span class="keyword">type</span> time_lock_proof</span></code></div><div class="spec-doc"><p>Proof that the opening of a value is the claimed value. Is concretely a member of the RSA group.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-locked_value" class="anchored"><a href="#type-locked_value" class="anchor"></a><code><span><span class="keyword">type</span> locked_value</span></code></div><div class="spec-doc"><p>Locked value that can be quickly access with a secret or slowly-access with a number of sequential operations. Is concretely a member of the RSA group.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-unlocked_value" class="anchored"><a href="#type-unlocked_value" class="anchor"></a><code><span><span class="keyword">type</span> unlocked_value</span></code></div><div class="spec-doc"><p>Member of the RSA group that we will lock. In our case it represents a symmetric key.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ciphertext" class="anchored"><a href="#type-ciphertext" class="anchor"></a><code><span><span class="keyword">type</span> ciphertext</span></code></div><div class="spec-doc"><p>A symmetric ciphertext and message authentication code, containing the bytes we want to protect</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gen_rsa_keys" class="anchored"><a href="#val-gen_rsa_keys" class="anchor"></a><code><span><span class="keyword">val</span> gen_rsa_keys : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-rsa_public">rsa_public</a> * <a href="#type-rsa_secret">rsa_secret</a></span></code></div><div class="spec-doc"><p>Generates random RSA keys of 2046 bits. The size works only if we use them for a small amount of time. !!! NEW KEYS SHOULD BE GENERATED FOR EACH LOCKING !!!</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">[Failure]</span> <p>if there is not enough entropy available.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-gen_locked_value" class="anchored"><a href="#val-gen_locked_value" class="anchor"></a><code><span><span class="keyword">val</span> gen_locked_value : <span><a href="#type-rsa_public">rsa_public</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-locked_value">locked_value</a></span></code></div><div class="spec-doc"><p>Generates almost uniformly an integer mod n. It is in the RSA group with overwhelming probability. We use this since we want to lock symmetric keys, not pre-determined messages.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">[Failure]</span> <p>if there is not enough entropy available.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unlocked_value_to_symmetric_key" class="anchored"><a href="#val-unlocked_value_to_symmetric_key" class="anchor"></a><code><span><span class="keyword">val</span> unlocked_value_to_symmetric_key : <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-symmetric_key">symmetric_key</a></span></code></div><div class="spec-doc"><p>Hashes a number mod n to a symmetric key for authenticated encryption.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-locked_value_to_symmetric_key_with_secret" class="anchored"><a href="#val-locked_value_to_symmetric_key_with_secret" class="anchor"></a><code><span><span class="keyword">val</span> locked_value_to_symmetric_key_with_secret : <span><a href="#type-rsa_secret">rsa_secret</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-symmetric_key">symmetric_key</a></span></code></div><div class="spec-doc"><p>Unlock a value using RSA secret and hash the result to derive a symmetric key using <code>unlocked_value_to_symmetric_key</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-unlock_with_secret" class="anchored"><a href="#val-unlock_with_secret" class="anchor"></a><code><span><span class="keyword">val</span> unlock_with_secret : <span><a href="#type-rsa_secret">rsa_secret</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-unlocked_value">unlocked_value</a></span></code></div><div class="spec-doc"><p>Unlock a value using the RSA secret.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unlock_and_prove_with_secret" class="anchored"><a href="#val-unlock_and_prove_with_secret" class="anchor"></a><code><span><span class="keyword">val</span> unlock_and_prove_with_secret : <span><a href="#type-rsa_secret">rsa_secret</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-unlocked_value">unlocked_value</a> * <a href="#type-time_lock_proof">time_lock_proof</a></span></code></div><div class="spec-doc"><p>Unlock a value using the RSA secret. Also produces a proof certifying that the result is indeed what had been locked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unlock_and_prove_without_secret" class="anchored"><a href="#val-unlock_and_prove_without_secret" class="anchor"></a><code><span><span class="keyword">val</span> unlock_and_prove_without_secret : <span><a href="#type-rsa_public">rsa_public</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-unlocked_value">unlocked_value</a> * <a href="#type-time_lock_proof">time_lock_proof</a></span></code></div><div class="spec-doc"><p>Unlock a value the slow way, without the RSA secret. Also produces a proof certifying that the result is indeed what had been locked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prove_without_secret" class="anchored"><a href="#val-prove_without_secret" class="anchor"></a><code><span><span class="keyword">val</span> prove_without_secret : <span><a href="#type-rsa_public">rsa_public</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-time_lock_proof">time_lock_proof</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prove_with_secret" class="anchored"><a href="#val-prove_with_secret" class="anchor"></a><code><span><span class="keyword">val</span> prove_with_secret : <span><a href="#type-rsa_secret">rsa_secret</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-time_lock_proof">time_lock_proof</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-verify_time_lock" class="anchored"><a href="#val-verify_time_lock" class="anchor"></a><code><span><span class="keyword">val</span> verify_time_lock : <span><a href="#type-rsa_public">rsa_public</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-time_lock_proof">time_lock_proof</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Verifies that <code>locked_value</code> indeed contains <code>unlocked_value</code> with parameters <code>rsa_public</code> and <code>time:Z.t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-locked_value_to_symmetric_key_with_proof" class="anchored"><a href="#val-locked_value_to_symmetric_key_with_proof" class="anchor"></a><code><span><span class="keyword">val</span> locked_value_to_symmetric_key_with_proof : <span><a href="#type-rsa_public">rsa_public</a> <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-time_lock_proof">time_lock_proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-symmetric_key">symmetric_key</a> option</span></span></code></div><div class="spec-doc"><p>Receives a claim opening with a proof. If the proof is valid hashes the opening using <code>unlocked_value_to_symmetric_key</code>, returns None otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encrypt" class="anchored"><a href="#val-encrypt" class="anchor"></a><code><span><span class="keyword">val</span> encrypt : <span><a href="#type-symmetric_key">symmetric_key</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-ciphertext">ciphertext</a></span></code></div><div class="spec-doc"><p>encrypt using authenticated encryption, i.e. ciphertext contains a ciphertext and a message authentication code.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decrypt" class="anchored"><a href="#val-decrypt" class="anchor"></a><code><span><span class="keyword">val</span> decrypt : <span><a href="#type-symmetric_key">symmetric_key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ciphertext">ciphertext</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes option</span></span></code></div><div class="spec-doc"><p>Checks the message authentication code. If correct decrypt the ciphertext, otherwise returns None.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-chest" class="anchored"><a href="#type-chest" class="anchor"></a><code><span><span class="keyword">type</span> chest</span><span> = </span><span>{</span></code><table><tr id="type-chest.locked_value" class="anchored"><td class="def record field"><a href="#type-chest.locked_value" class="anchor"></a><code><span>locked_value : <a href="#type-locked_value">locked_value</a>;</span></code></td></tr><tr id="type-chest.time" class="anchored"><td class="def record field"><a href="#type-chest.time" class="anchor"></a><code><span>time : <span class="xref-unresolved">Z</span>.t;</span></code></td></tr><tr id="type-chest.rsa_public" class="anchored"><td class="def record field"><a href="#type-chest.rsa_public" class="anchor"></a><code><span>rsa_public : <a href="#type-rsa_public">rsa_public</a>;</span></code></td></tr><tr id="type-chest.ciphertext" class="anchored"><td class="def record field"><a href="#type-chest.ciphertext" class="anchor"></a><code><span>ciphertext : <a href="#type-ciphertext">ciphertext</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Contains a value (the decryption of the ciphertext) that can be provably recovered in <code>time</code> sequential operation or with the rsa secret.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chest_encoding" class="anchored"><a href="#val-chest_encoding" class="anchor"></a><code><span><span class="keyword">val</span> chest_encoding : <span><a href="#type-chest">chest</a> <span class="xref-unresolved">Data_encoding</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-chest_key" class="anchored"><a href="#type-chest_key" class="anchor"></a><code><span><span class="keyword">type</span> chest_key</span><span> = </span><span>{</span></code><table><tr id="type-chest_key.unlocked_value" class="anchored"><td class="def record field"><a href="#type-chest_key.unlocked_value" class="anchor"></a><code><span>unlocked_value : <a href="#type-unlocked_value">unlocked_value</a>;</span></code></td></tr><tr id="type-chest_key.proof" class="anchored"><td class="def record field"><a href="#type-chest_key.proof" class="anchor"></a><code><span>proof : <a href="#type-time_lock_proof">time_lock_proof</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Provably opens a chest in a short time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chest_key_encoding" class="anchored"><a href="#val-chest_key_encoding" class="anchor"></a><code><span><span class="keyword">val</span> chest_key_encoding : <span><a href="#type-chest_key">chest_key</a> <span class="xref-unresolved">Data_encoding</span>.t</span></span></code></div></div><p>Result of the opening of a chest. The opening can fail in two way which we distinguish to blame the right party. One can provide a false unlocked_value or unlocked_proof, in which case we return <code>Bogus_opening</code> and the provider of the chest key is at fault. Othewise, one can lock the wrong key or put garbage in the ciphertext in which case we return <code>Bogus_cipher</code> and the provider of the chest is at fault. Otherwise we return <code>Correct payload</code> where <code>payload</code> is the content that had originally been put in the chest.</p><div class="odoc-spec"><div class="spec type" id="type-opening_result" class="anchored"><a href="#type-opening_result" class="anchor"></a><code><span><span class="keyword">type</span> opening_result</span><span> = </span></code><table><tr id="type-opening_result.Correct" class="anchored"><td class="def variant constructor"><a href="#type-opening_result.Correct" class="anchor"></a><code><span>| </span><span><span class="constructor">Correct</span> <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></td></tr><tr id="type-opening_result.Bogus_cipher" class="anchored"><td class="def variant constructor"><a href="#type-opening_result.Bogus_cipher" class="anchor"></a><code><span>| </span><span><span class="constructor">Bogus_cipher</span></span></code></td></tr><tr id="type-opening_result.Bogus_opening" class="anchored"><td class="def variant constructor"><a href="#type-opening_result.Bogus_opening" class="anchor"></a><code><span>| </span><span><span class="constructor">Bogus_opening</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-open_chest" class="anchored"><a href="#val-open_chest" class="anchor"></a><code><span><span class="keyword">val</span> open_chest : <span><a href="#type-chest">chest</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-chest_key">chest_key</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-opening_result">opening_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_chest_and_chest_key" class="anchored"><a href="#val-create_chest_and_chest_key" class="anchor"></a><code><span><span class="keyword">val</span> create_chest_and_chest_key : <span>payload:<span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span>time:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-chest">chest</a> * <a href="#type-chest_key">chest_key</a></span></code></div><div class="spec-doc"><p>High level function which takes care of generating the locked value, the RSA parameters, and encrypt the payload. Also returns the chest key</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_chest_key" class="anchored"><a href="#val-create_chest_key" class="anchor"></a><code><span><span class="keyword">val</span> create_chest_key : <span><a href="#type-chest">chest</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-chest_key">chest_key</a></span></code></div><div class="spec-doc"><p>High level function which unlock the value and create the time-lock proof.</p></div></div></div></body></html>