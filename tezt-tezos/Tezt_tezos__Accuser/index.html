<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tezt_tezos__Accuser (tezt-tezos.Tezt_tezos__Accuser)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">tezt-tezos</a> &#x00BB; Tezt_tezos__Accuser</nav><h1>Module <code>Tezt_tezos__Accuser</code></h1><p>Spawn Tezos accuser and control them.</p><nav class="toc"><ul><li><a href="#commands">Commands</a></li><li><a href="#events">Events</a></li><li><a href="#high-level-functions">High-Level Functions</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Tezos accuser states.</p></dd></dl><dl><dt class="spec type" id="type-event"><a href="#type-event" class="anchor"></a><code><span class="keyword">type</span> event</code><code> = </code><code>{</code><table class="record"><tr id="type-event.name" class="anchored"><td class="def field"><a href="#type-event.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-event.value" class="anchored"><td class="def field"><a href="#type-event.value" class="anchor"></a><code>value : <a href="../../tezt/Tezt/JSON/index.html#type-t">Tezt.JSON.t</a>;</code></td></tr></table><code>}</code></dt><dd><p>Raw events.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>protocol:<a href="../Tezt_tezos/Protocol/index.html#type-t">Tezt_tezos.Protocol.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>?&#8288;color:<a href="../../tezt/Tezt/Log/Color/index.html#type-t">Tezt.Log.Color.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;event_pipe:string</span> <span>&#45;&gt;</span> <span>?&#8288;base_dir:string</span> <span>&#45;&gt;</span> <span>?&#8288;runner:<a href="../../tezt/Tezt/Runner/index.html#type-t">Tezt.Runner.t</a></span> <span>&#45;&gt;</span> <a href="../Tezt_tezos/Node/index.html#type-t">Tezt_tezos.Node.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create an accuser.</p><p>This function just creates the <code>t</code> value, it does not call <code>run</code>.</p><p>The path to accuser binary is chosen from the <code>protocol</code>.</p><p>The standard output and standard error output of the accuser will be logged with prefix <code>name</code> and color <code>color</code>.</p><p>Default <code>event_pipe</code> is a temporary file whose name is derived from <code>name</code>. It will be created as a named pipe so that accuser events can be received.</p><p><code>base_dir</code> corresponds to the (useless) &quot;--base-dir&quot; argument of the tezos-accuser command.</p><p>The <code>Node.t</code> parameter is the accuser's node target. The accuser will be configured to be synchronised with the given node, and will communicate with it.</p><p>If <code>runner</code> is specified, the accuser will be spawned on this runner using SSH.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Get the name of an accuser.</p></dd></dl><dl><dt class="spec value" id="val-node_rpc_port"><a href="#val-node_rpc_port" class="anchor"></a><code><span class="keyword">val</span> node_rpc_port : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Get the RPC port of the associated node.</p></dd></dl><dl><dt class="spec value" id="val-terminate"><a href="#val-terminate" class="anchor"></a><code><span class="keyword">val</span> terminate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Send SIGTERM to an accuser and wait for it to terminate.</p></dd></dl><section><header><h3 id="commands"><a href="#commands" class="anchor"></a>Commands</h3></header><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Spawn <code>tezos-accuser run</code>.</p><p>The resulting promise is fulfilled as soon as the accuser has been spawned. It continues running in the background.</p></dd></dl></section><section><header><h3 id="events"><a href="#events" class="anchor"></a>Events</h3></header><dl><dt class="spec exception" id="exception-Terminated_before_event"><a href="#exception-Terminated_before_event" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Terminated_before_event</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".daemon" class="anchored"><td class="def field"><a href="#.daemon" class="anchor"></a><code>daemon : string;</code></td></tr><tr id=".event" class="anchored"><td class="def field"><a href="#.event" class="anchor"></a><code>event : string;</code></td></tr><tr id=".where" class="anchored"><td class="def field"><a href="#.where" class="anchor"></a><code>where : <span>string option</span>;</code></td></tr></table><code>}</code></dt><dd><p>Exception raised by <code>wait_for</code> functions if the node terminates before the event.</p><p>You may catch or let it propagate to cause the test to fail. <code>daemon</code> is the name of the accuser. <code>event</code> is the name of the event. <code>where</code> is an additional optional constraint, such as <code>&quot;level &gt;= 10&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-wait_for_ready"><a href="#val-wait_for_ready" class="anchor"></a><code><span class="keyword">val</span> wait_for_ready : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Wait until the accuser is ready.</p><p>More precisely, wait until the node on which the accuser is connected to is bootstrapped, and then, the accuser is ready.</p></dd></dl><dl><dt class="spec value" id="val-wait_for"><a href="#val-wait_for" class="anchor"></a><code><span class="keyword">val</span> wait_for : <span>?&#8288;where:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>(<a href="../../tezt/Tezt/JSON/index.html#type-t">Tezt.JSON.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span></code></dt><dd><p>Wait for a custom event to occur.</p><p>Usage: <code>wait_for accuser name filter</code></p><p>If an event named <code>name</code> occurs, apply <code>filter</code> to its value. If <code>filter</code> returns <code>None</code>, continue waiting. If <code>filter</code> returns <code>Some x</code>, return <code>x</code>.</p><p><code>where</code> is used as the <code>where</code> field of the <code>Terminated_before_event</code> exception if the accuser terminates. It should describe the constraint that <code>filter</code> applies, such as <code>&quot;field level exists&quot;</code>.</p><p>It is advised to register such event handlers before starting the accuser, as if they occur before being registered, they will not trigger your handler. For instance, you can define a promise with <code>let x_event = wait_for accuser &quot;x&quot; (fun x -&gt; Some x)</code> and bind it later with <code>let* x = x_event</code>.</p></dd></dl><dl><dt class="spec value" id="val-on_event"><a href="#val-on_event" class="anchor"></a><code><span class="keyword">val</span> on_event : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-event">event</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a callback to be called whenever the accuser emits an event.</p><p>Contrary to <code>wait_for</code> functions, this callback is never removed.</p><p>Listening to events with <code>on_event</code> will not prevent <code>wait_for</code> promises to be fulfilled. You can also have multiple <code>on_event</code> handlers, although the order in which they trigger is unspecified.</p></dd></dl><dl><dt class="spec value" id="val-log_events"><a href="#val-log_events" class="anchor"></a><code><span class="keyword">val</span> log_events : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Register an event handler that logs all events.</p><p>Use this when you need to debug or reverse engineer incoming events. Usually you do not want to keep that in the final versions of your tests.</p></dd></dl></section><section><header><h3 id="high-level-functions"><a href="#high-level-functions" class="anchor"></a>High-Level Functions</h3></header><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>protocol:<a href="../Tezt_tezos/Protocol/index.html#type-t">Tezt_tezos.Protocol.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>?&#8288;color:<a href="../../tezt/Tezt/Log/Color/index.html#type-t">Tezt.Log.Color.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;event_pipe:string</span> <span>&#45;&gt;</span> <span>?&#8288;base_dir:string</span> <span>&#45;&gt;</span> <span>?&#8288;runner:<a href="../../tezt/Tezt/Runner/index.html#type-t">Tezt.Runner.t</a></span> <span>&#45;&gt;</span> <a href="../Tezt_tezos/Node/index.html#type-t">Tezt_tezos.Node.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Lwt.t</span></code></dt><dd><p>Initialize an accuser.</p><p>This <a href="index.html#val-create"><code>create</code></a>s an accuser and <a href="index.html#val-run"><code>run</code></a>, then waits for the accuser to be ready, and finally returns the accuser.</p><p>As the accuser usually needs to be connected to a node, we first wait for the node to be ready and then, run the accuser. If one does not want to wait for the node to be ready, it is necessary to use <code>create</code> and then <code>run</code>.</p><p>The path to accuser binary is chosen from the <code>protocol</code>.</p><p>The standard output and standard error output of the accuser will be logged with prefix <code>name</code> and color <code>color</code>.</p><p>Default <code>event_pipe</code> is a temporary file whose name is derived from <code>name</code>. It will be created as a named pipe so that accuser events can be received.</p><p><code>base_dir</code> corresponds to the (useless) &quot;--base-dir&quot; argument of the tezos-accuser command.</p><p>The <code>Node.t</code> parameter is the accuser's node target. The accuser will be configured to be synchronised with the given node, and will communicate with it.</p><p>If <code>runner</code> is specified, the accuser will be spawned on this runner using SSH.</p></dd></dl><dl><dt class="spec value" id="val-restart"><a href="#val-restart" class="anchor"></a><code><span class="keyword">val</span> restart : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Restart an accuser.</p><p>This <a href="index.html#val-terminate"><code>terminate</code></a>s an accuser, then <a href="index.html#val-run"><code>run</code></a>s it again and waits for it to be ready.</p></dd></dl></section></div></body></html>