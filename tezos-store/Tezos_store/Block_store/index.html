<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Block_store (tezos-store.Tezos_store.Block_store)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-store</a> &#x00BB; <a href="../index.html">Tezos_store</a> &#x00BB; Block_store</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_store.Block_store</span></code></h1><p>Persistent and cached generic block store</p><p>The store instantiate a cemented block store and multiple floating block stores. The floating stores serve as buffers until enough blocks have arrived. Then it performs a &quot;cementing&quot; (also called a &quot;merge&quot;). Under normal circumstances, there are two different kinds (<a href="../Floating_block_store/index.html#type-floating_kind"><code>Floating_block_store.floating_kind</code></a>) of floating stores instances: a <code>RO</code>(read-only) and a <code>RW</code>(read-write). Newly arrived blocks are <b>always</b> pushed in the <code>RW</code> instance. The block lookup is first tried in <code>RW</code>, then <code>RO</code> and finally in the cement blocks.</p><p>This store also instantiates a LRU block cache to reduce the number of I/O operations. This cache is updated whenever a block is read or stored.</p><p>When a merge occurs, the <code>RW</code> instance is promoted as another <code>RO'</code> and a new <code>RW'</code> instance replaces it. This allows retrieving the new cycle to be cemented from <code>RO</code> and <code>RO'</code> (former <code>RW</code>) <b>asynchronously</b> and thus allowing new blocks to be stored in the newly instantiated <code>RW</code> store without pausing. This asynchronous merging thread, while retrieving the cycle to cement, also combines <code>RO</code> and <code>RO'</code> into a <b>new</b> <code>RO''</code> without the cemented cycle. When the merging thread is done, the former <code>RO</code> and <code>RO'</code> instances are deleted from the disk and the new <code>RO''</code> replaces them. A merging thread has to wait for the previous one to finish.</p><p>Retrieving the new cycle from <code>RO</code> and <code>RO'</code> from blocks <code>B_start</code> and <code>B_end</code> means that we must retrieve the set of blocks between them but also trim potential branches that have roots in this set. To achieve that, we iterate over <code>RO</code> and <code>RO'</code> <b>linearly</b>. This means that <b>every block's predecessor in floating stores must be previously known</b>. Either we previously encountered it in the same floating store file, either in <code>RO</code> if the block is in <code>RO'</code> or in the cemented store (see invariants below). This invariant is required to ensure minimal memory usage. The iterations done to retrieve the cycle and merge the floating stores works similarly to a <i>stop and copy</i> GC algorithm. It works as follows:</p><ul><li>We retrieve the blocks from <code>B_end</code> to <code>B_start</code> by sequentially reading predecessors.</li></ul><ul><li>We instantiate a set of encountered block hashes with <code>B_end</code>'s hash as initial value.</li></ul><ul><li>We iterate sequentially over <code>RO</code> and <code>RO'</code> blocks and copy them only if their predecessors is present in the visited set, adding their hash in the process.</li></ul><p>The result is a correct, in order and trimmed new <code>RO</code> floating store. A visual example of merging is given below.</p><p>The merging thread will also trigger a garbage-collection of the cemented block store w.r.t. the given history mode.</p></header><nav class="odoc-toc"><ul><li><a href="#invariants">Invariants</a></li><li><a href="#merging-example">Merging example</a></li></ul></nav><div class="odoc-content"><h2 id="invariants"><a href="#invariants" class="anchor"></a>Invariants</h2><p>This store is expected to respect the following invariants:</p><ul><li>If no merging thread is pending, two floating stores are present: a <code>RO</code> and a <code>RW</code>.</li></ul><ul><li>If a merging thread is pending, there are three floating stores present: a <code>RO</code>, a <code>RO'</code> and a <code>RW</code>.</li></ul><ul><li>Blocks may be stored twice in <b>floating stores</b> but only when a merging occurs (as <code>RO''</code> is a subset of <code>RO</code>+<code>RO'</code>). However, blocks can be present in both the cemented and the floating store (after importing a storage snapshot as the floating block store consist in a checkpoint associated with its `max_op_ttl` blocks which were already cemented).</li></ul><ul><li>For every stored block in floating stores, its predecessor is either already stored in the same floating store file, in a previous floating store file or in the cemented store.</li></ul><ul><li>A merging thread does not start until the previous one has completed.</li></ul><h2 id="merging-example"><a href="#merging-example" class="anchor"></a>Merging example</h2><pre>           RO          RW

                 | C' - D' - E'   G'
              /  |               /
         A - B - | C - D - E - F - G
                 |  \
                 |    D'' - E''
                 |     \
                 |       E'''</pre><p>For instance, a merging from <code>A</code> to <code>C</code> will first retrieve blocks <code>C</code>, <code>B</code> and <code>A</code>. Then, iterate over all the blocks in both the <code>RO</code> and <code>RW</code> files: reading first in <code>RO</code>, then in <code>RW</code>. By construction, blocks are stored after their predecessors. For example, [ A ; B ; C ; C'; D'' ; D'; D ; E ; E'' ; F ; E''' ; G' ; G ] is a valid storing sequence.</p><p>The algorithm starts iterating over this sequence and will only copy blocks for which predecessors are present in the set S of hash (initially S = { hash(<code>C</code>) }). Thus, for the given sequence, <code>D''</code> will first be considered, S will be updated to { hash(<code>C</code>), hash(<code>D</code>) } and so on, until <code>RO</code> and <code>RW</code> are fully read.</p><p>The new RO will then be:</p><pre>                G'
               /
    - D - E - F - G

    - D'' - E''
       \
        E'''</pre><p>where its storing order will be correct with regards to the invariant.</p><div class="odoc-spec"><div class="spec type" id="type-block_store" class="anchored"><a href="#type-block_store" class="anchor"></a><code><span><span class="keyword">type</span> block_store</span></code></div><div class="spec-doc"><p>The type of the block store</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="#type-block_store">block_store</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-key" class="anchored"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = </span></code><table><tr id="type-key.Block" class="anchored"><td class="def variant constructor"><a href="#type-key.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <a href="../../../tezos-crypto/Tezos_crypto/Block_hash/index.html#type-t">Tezos_crypto.Block_hash.t</a> * int</span></code></td></tr></table></div><div class="spec-doc"><p>The type of the block's key to be accessed: a hash and an offset.</p><ul><li>Block (h, 0) represents the block h itself ;</li></ul><ul><li>Block (h, n) represents the block's <code>n</code>th predecessor.</li></ul><p>A block key may represent an invalid block (wrong hash and/or offset) as it is not ensured to be valid by construction.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-merge_status" class="anchored"><a href="#type-merge_status" class="anchor"></a><code><span><span class="keyword">type</span> merge_status</span><span> = </span></code><table><tr id="type-merge_status.Not_running" class="anchored"><td class="def variant constructor"><a href="#type-merge_status.Not_running" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_running</span></span></code></td></tr><tr id="type-merge_status.Running" class="anchored"><td class="def variant constructor"><a href="#type-merge_status.Running" class="anchor"></a><code><span>| </span><span><span class="constructor">Running</span></span></code></td></tr><tr id="type-merge_status.Merge_failed" class="anchored"><td class="def variant constructor"><a href="#type-merge_status.Merge_failed" class="anchor"></a><code><span>| </span><span><span class="constructor">Merge_failed</span> <span class="keyword">of</span> <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span></span></code></td></tr></table></div><div class="spec-doc"><p>The status of the merging thread</p></div></div><div class="odoc-spec"><div class="spec type" id="type-status" class="anchored"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span></code><table><tr id="type-status.Idle" class="anchored"><td class="def variant constructor"><a href="#type-status.Idle" class="anchor"></a><code><span>| </span><span><span class="constructor">Idle</span></span></code></td></tr><tr id="type-status.Merging" class="anchored"><td class="def variant constructor"><a href="#type-status.Merging" class="anchor"></a><code><span>| </span><span><span class="constructor">Merging</span></span></code></td></tr></table></div><div class="spec-doc"><p>The status of the store</p></div></div><div class="odoc-spec"><div class="spec value" id="val-status_encoding" class="anchored"><a href="#val-status_encoding" class="anchor"></a><code><span><span class="keyword">val</span> status_encoding : <span><a href="#type-status">status</a> <span class="xref-unresolved">Tezos_base__TzPervasives</span>.Data_encoding.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-cemented_block_store" class="anchored"><a href="#val-cemented_block_store" class="anchor"></a><code><span><span class="keyword">val</span> cemented_block_store : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Cemented_block_store/index.html#type-t">Cemented_block_store.t</a></span></code></div><div class="spec-doc"><p><code>cemented_block_store block_store</code> returns the instance of the cemented block store for <code>block_store</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-floating_block_stores" class="anchored"><a href="#val-floating_block_stores" class="anchor"></a><code><span><span class="keyword">val</span> floating_block_stores : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Floating_block_store/index.html#type-t">Floating_block_store.t</a> list</span></span></code></div><div class="spec-doc"><p><code>floating_block_stores block_store</code> returns all running floating block store instances for <code>block_store</code>. It will always return two or three ordered floating stores:</p><ul><li><code> [RO] ; [RW] </code> if a merge is not occurring;</li></ul><ul><li><code> [RO] ; [RO'] ; [RW] </code> if a merge is occurring.</li></ul><p><b>Warning</b> These stores should only be accessed when the store is not active.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-savepoint" class="anchored"><a href="#val-savepoint" class="anchor"></a><code><span><span class="keyword">val</span> savepoint : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Store_types/index.html#type-block_descriptor">Store_types.block_descriptor</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_savepoint" class="anchored"><a href="#val-write_savepoint" class="anchor"></a><code><span><span class="keyword">val</span> write_savepoint : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Store_types/index.html#type-block_descriptor">Store_types.block_descriptor</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-caboose" class="anchored"><a href="#val-caboose" class="anchor"></a><code><span><span class="keyword">val</span> caboose : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Store_types/index.html#type-block_descriptor">Store_types.block_descriptor</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_caboose" class="anchored"><a href="#val-write_caboose" class="anchor"></a><code><span><span class="keyword">val</span> write_caboose : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Store_types/index.html#type-block_descriptor">Store_types.block_descriptor</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-status" class="anchored"><a href="#val-status" class="anchor"></a><code><span><span class="keyword">val</span> status : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-status">status</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_status" class="anchored"><a href="#val-write_status" class="anchor"></a><code><span><span class="keyword">val</span> write_status : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-status">status</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-genesis_block" class="anchored"><a href="#val-genesis_block" class="anchor"></a><code><span><span class="keyword">val</span> genesis_block : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Block_repr/index.html#type-t">Block_repr.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem block_store key</code> tests the existence of the block <code>key</code> in <code>block_store</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_hash" class="anchored"><a href="#val-get_hash" class="anchor"></a><code><span><span class="keyword">val</span> get_hash : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="../../../tezos-crypto/Tezos_crypto/Block_hash/index.html#type-t">Tezos_crypto.Block_hash.t</a> option</span>,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>get_hash block_store key</code> retrieves the hash corresponding to the given <code>key</code> in <code>block_store</code>. Return <code>None</code> if the block is unknown.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_block" class="anchored"><a href="#val-read_block" class="anchor"></a><code><span><span class="keyword">val</span> read_block : <span>read_metadata:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="../Block_repr/index.html#type-t">Block_repr.t</a> option</span>,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_block ~read_metadata block_store key</code> reads the block <code>key</code> in <code>block_store</code> if present. Return <code>None</code> if the block is unknown.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_block_metadata" class="anchored"><a href="#val-read_block_metadata" class="anchor"></a><code><span><span class="keyword">val</span> read_block_metadata : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="../Block_repr/index.html#type-metadata">Block_repr.metadata</a> option</span>,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_block_metadata block_store key</code> reads the metadata for the block <code>key</code> in <code>block_store</code> if present. Return <code>None</code> if the block is unknown or if the metadata are not present.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-store_block" class="anchored"><a href="#val-store_block" class="anchor"></a><code><span><span class="keyword">val</span> store_block : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Block_repr/index.html#type-t">Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>store_block block_store block</code> stores the <code>block</code> in the current <code>RW</code> floating store.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cement_blocks" class="anchored"><a href="#val-cement_blocks" class="anchor"></a><code><span><span class="keyword">val</span> cement_blocks : <span>?check_consistency:bool <span class="arrow">&#45;&gt;</span></span> <span>write_metadata:bool <span class="arrow">&#45;&gt;</span></span>
<span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Block_repr/index.html#type-t">Block_repr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>cement_blocks ?check_consistency ~write_metadata block_store
    chunk</code></p><p>Wrapper of <a href="../Cemented_block_store/index.html#val-cement_blocks"><code>Cemented_block_store.cement_blocks</code></a>. If the flag <code>check_consistency</code> is set, it verifies that all blocks in <code>chunk</code> are in a consecutive order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-move_floating_store" class="anchored"><a href="#val-move_floating_store" class="anchor"></a><code><span><span class="keyword">val</span> move_floating_store : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>src:<a href="../Floating_block_store/index.html#type-t">Floating_block_store.t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_kind:<a href="../Floating_block_store/index.html#type-floating_kind">Floating_block_store.floating_kind</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>move_floating_store block_store ~src ~dst_kind</code> closes the floating store <code>src</code>, tests the existence of a <code>dst_kind</code> store opened in <code>block_store</code> and tries to close it if it is the case. It then proceeds to replace the files from <code>src</code> to <code>dst</code>.</p><p>This function is unsafe and should only be called in very specific cases.</p><p><b>Warning</b> <code>block_store</code> remains unchanged meaning that the potential deleted floating store is referenced in the structure.</p><p>Fails if both <code>src</code> and <code>dst</code> (if it exists) have the same <a href="../Floating_block_store/index.html#type-floating_kind"><code>Floating_block_store.floating_kind</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-await_merging" class="anchored"><a href="#val-await_merging" class="anchor"></a><code><span><span class="keyword">val</span> await_merging : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>await_merging block_store</code> waits for the current merging thread in <code>block_store</code> to finish if any.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_stores" class="anchored"><a href="#val-merge_stores" class="anchor"></a><code><span><span class="keyword">val</span> merge_stores : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>on_error:<span>(<span><span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>finalizer:<span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>history_mode:<a href="../../../tezos-shell-services/Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span>new_head:<a href="../Block_repr/index.html#type-t">Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
<span>new_head_metadata:<a href="../Block_repr/index.html#type-metadata">Block_repr.metadata</a> <span class="arrow">&#45;&gt;</span></span> <span>cementing_highwatermark:int32 <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>(* TODO UPDATE MERGE DOC *) <code>merge_stores block_store ?finalizer ~nb_blocks_to_preserve
    ~history_mode ~from_block ~to_block</code> triggers a merge as described in the above description. This will result, <b>asynchronously</b>, in:</p><ul><li>the cementing (if needs be) of a cycle from <code>from_block</code> to <code>to_block</code> (included)</li></ul><ul><li>trimming the floating stores and preserves <code>to_block</code> - <code>nb_blocks_to_preserve</code> blocks (iff these blocks are present or the longest suffix otherwise) along with their metadata in the floating store. It may potentially have duplicates in the cemented block store.</li></ul><p>After the cementing, <a href="../Cemented_block_store/index.html#val-trigger_gc"><code>Cemented_block_store.trigger_gc</code></a> will be called with the given <code>history_mode</code>. When the merging thread succeeds, the callback <code>finalizer</code> will be called.</p><p>If a merge thread is already occurring, this function will first wait for the previous merge to be done.</p><p><b>Warning</b> For a given <code>block_store</code>, the caller must wait for this function termination before calling it again or it may result in concurrent intertwining causing the cementing to be out of order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_merge_status" class="anchored"><a href="#val-get_merge_status" class="anchor"></a><code><span><span class="keyword">val</span> get_merge_status : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-merge_status">merge_status</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_merge_status" class="anchored"><a href="#val-pp_merge_status" class="anchor"></a><code><span><span class="keyword">val</span> pp_merge_status : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-merge_status">merge_status</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-switch_history_mode" class="anchored"><a href="#val-switch_history_mode" class="anchor"></a><code><span><span class="keyword">val</span> switch_history_mode : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>current_head:<a href="../Block_repr/index.html#type-t">Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>previous_history_mode:<a href="../../../tezos-shell-services/Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span>
<span>new_history_mode:<a href="../../../tezos-shell-services/Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>switch_history_mode block_store ~current_head
   ~previous_history_mode ~new_history_mode</code> switches the store from the <code>previous_history_mode</code> to the given <code>new_history_mode</code>. To do so, it infers and updates both the caboose and savepoint. If needed, a garbage collection of unnecessary cycles is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span><span>[ `Chain_dir ]</span> <a href="../Naming/index.html#type-directory">Naming.directory</a></span> <span class="arrow">&#45;&gt;</span></span> <span>genesis_block:<a href="../Block_repr/index.html#type-t">Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-block_store">block_store</a>,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>create ~chain_dir ~genesis_block</code> instantiates a fresh <code>block_store</code> in directory <code>chain_dir</code> and stores the <code>genesis_block</code> in it. It fails if the given <code>chain_dir</code> is already populated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-load" class="anchored"><a href="#val-load" class="anchor"></a><code><span><span class="keyword">val</span> load : <span><span><span>[ `Chain_dir ]</span> <a href="../Naming/index.html#type-directory">Naming.directory</a></span> <span class="arrow">&#45;&gt;</span></span> <span>genesis_block:<a href="../Block_repr/index.html#type-t">Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>readonly:bool <span class="arrow">&#45;&gt;</span></span>
<span><span><span>(<a href="#type-block_store">block_store</a>,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>load chain_dir ~genesis_block ~readonly</code> loads an existing block_store from directory <code>chain_dir</code>. Setting <code>readonly</code> will prevent new blocks from being stored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>close block_store</code> closes the <code>block_store</code> and every underlying opened stores.</p><p><b>Warning</b> If a merging thread is occurring, it will wait up to 5s for its termination before effectively closing the store.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-may_recover_merge" class="anchored"><a href="#val-may_recover_merge" class="anchor"></a><code><span><span class="keyword">val</span> may_recover_merge : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit,Â <span><a href="../../../tezos-error-monad/Tezos_error_monad/TzCore/index.html#type-error">Tezos_error_monad.TzCore.error</a> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>may_recover_merge block_store</code> recovers, if needed, from a <code>block_store</code> where the merge procedure was unexpectedly interrupted.</p></div></div></div></body></html>