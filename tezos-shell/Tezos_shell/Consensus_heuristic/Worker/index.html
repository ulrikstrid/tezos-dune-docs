<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Worker (tezos-shell.Tezos_shell.Consensus_heuristic.Worker)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">tezos-shell</a> &#x00BB; <a href="../../index.html">Tezos_shell</a> &#x00BB; <a href="../index.html">Consensus_heuristic</a> &#x00BB; Worker</nav><h1>Module <code>Consensus_heuristic.Worker</code></h1><p>This worker implements a memoisation mechanism for the consensus heuristic with an expiry date mechanism. The worker also handles a hook mechanism to be executed on values found by the consensus heuristic.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>A worker for a consensus over <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>expire_time:Ptime.Span.t</span> <span>&#45;&gt;</span> <span>job:<span>(unit <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-state">state</a></span> Lwt.t</span>)</span></span> <span>&#45;&gt;</span> <span>restart_delay:Ptime.Span.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>create ~expire_time ~job ~restart_delay</code> creates a worker.</p><ul><li><code>expire</code> is a span of time during which a found consensus is memoised. After this span of time has elapsed, the found consensus is invalidated and a new consensus will be sought the next time it is queried.</li></ul><ul><li><code>job</code> is the task the worker runs to seek a consensus. It is the responsibility of the caller to assemble <code>job</code> using the functions <a href="index.html#val-create"><code>create</code></a>, <a href="../index.html#val-update"><code>update</code></a>, and <a href="../index.html#val-get_state"><code>get_state</code></a> above.</li></ul><ul><li><code>restart_delay</code> is a span of time that elapses between a non-successful run of <code>job</code> (a run that returns <code>No_consensus</code> or <code>Need_more_candidates</code>), and the next run. The delay leaves some time to elapse so that the network data has time to evolve before attempting to find a consensus again.</li></ul><p>Note: Remember that the base heuristic states are meant to be short-lived. They are meant to be used as one-shot. Consequently, when you assemble a function for <code>job</code>, it should create a heuristic state, update it, and query it. You should <em>NOT</em> share a single heuristic state for multiple runs of <code>job</code>.</p></dd></dl><dl><dt class="spec value" id="val-wait"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span></code></dt><dd><p><code>wait worker</code> is a promise that resolves the next time the worker finds a consensus; i.e., the next time the worker's <code>job</code> returns <code>Consensus</code>.</p><p>If the worker has found a consensus less than <code>expire</code> time ago, the promise is already resolved with the found consensus.</p><p>If the worker is not currently seeking a consensus (and it doesn't have a currently memoised consensus), <code>job</code> is called again to seek one.</p></dd></dl><dl><dt class="spec value" id="val-on_next_consensus"><a href="#val-on_next_consensus" class="anchor"></a><code><span class="keyword">val</span> on_next_consensus : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>on_next_consensus worker hook</code> registers a hook to be executed on the next consensus found by the worker or the current one if there is a non-expired consensus (i.e., <code>Lwt.state (wait worker) = Lwt.Return hash</code>).</p><p>Hooks are executed in the same order they are registered.</p></dd></dl><dl><dt class="spec value" id="val-on_all_consensus"><a href="#val-on_all_consensus" class="anchor"></a><code><span class="keyword">val</span> on_all_consensus : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>on_all_consensus worker hook</code> registers a hook to be executed on every future consensus found by the worker as well as the current one if there is a valid consensus (i.e., <code>Lwt.state (wait worker) = Lwt.Return hash</code>).</p><p>It is guaranteed that a hook is executed exactly once for each time a consensus is reached. More precisely, between two executions of the same hook, there is at least one execution of <code>job</code>.</p><p>Hooks are executed in the same order they are registered.</p></dd></dl><dl><dt class="spec value" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span class="keyword">val</span> cancel : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>cancel worker</code> cancels the current task of the worker. All hooks are removed. If there are any pending promises returned by <code>wait</code>, they are canceled.</p></dd></dl></div></body></html>