<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bytes (tezos-protocol-updater.Tezos_protocol_updater.Registered_protocol.Register_embedded_V2.1-Env.Bytes)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">tezos-protocol-updater</a> &#x00BB; <a href="../../../../index.html">Tezos_protocol_updater</a> &#x00BB; <a href="../../../index.html">Registered_protocol</a> &#x00BB; <a href="../../index.html">Register_embedded_V2</a> &#x00BB; <a href="../index.html">1-Env</a> &#x00BB; Bytes</nav><header class="odoc-preamble"><h1>Module <code><span>1-Env.Bytes</span></code></h1><p>Byte sequence operations.</p><p>A byte sequence is a mutable data structure that contains a fixed-length sequence of bytes. Each byte can be indexed in constant time for reading or writing.</p><p>Given a byte sequence <code>s</code> of length <code>l</code>, we can access each of the <code>l</code> bytes of <code>s</code> via its index in the sequence. Indexes start at <code>0</code>, and we will call an index valid in <code>s</code> if it falls within the range <code>[0...l-1]</code> (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in <code>s</code> if it falls within the range <code>[0...l]</code> (inclusive). Note that the byte at index <code>n</code> is between positions <code>n</code> and <code>n+1</code>.</p><p>Two parameters <code>start</code> and <code>len</code> are said to designate a valid range of <code>s</code> if <code>len &gt;= 0</code> and <code>start</code> and <code>start+len</code> are valid positions in <code>s</code>.</p><p>Byte sequences can be modified in place, for instance via the <code>set</code> and <code>blit</code> functions described below. See also strings (module <a href="../String/index.html"><code>String</code></a>), which are almost the same data structure, but cannot be modified in place.</p><p>Bytes are represented by the OCaml type <code>char</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02.0</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value external" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>bytes <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of bytes) of the argument.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>Bytes.init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code> (in increasing index order).</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : bytes</span></code></div><div class="spec-doc"><p>A byte sequence of size 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a new byte sequence that contains the same bytes as the argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a new byte sequence that contains the same bytes as the given string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span>bytes <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a new string that contains the same bytes as the given byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub_string" class="anchored"><a href="#val-sub_string" class="anchor"></a><code><span><span class="keyword">val</span> sub_string : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Same as <code>sub</code> but return a string instead of a byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extend" class="anchored"><a href="#val-extend" class="anchor"></a><code><span><span class="keyword">val</span> extend : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>extend s left right</code> returns a new byte sequence that contains the bytes of <code>s</code>, with <code>left</code> uninitialized bytes prepended and <code>right</code> uninitialized bytes appended to it. If <code>left</code> or <code>right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if the result length is negative or longer than <code>Sys</code>.max_string_length bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fill" class="anchored"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_string" class="anchored"><a href="#val-blit_string" class="anchor"></a><code><span><span class="keyword">val</span> blit_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at index <code>dstoff</code>.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span><span>bytes list</span> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cat" class="anchored"><a href="#val-cat" class="anchor"></a><code><span><span class="keyword">val</span> cat : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>cat s1 s2</code> concatenates <code>s1</code> and <code>s2</code> and returns the result as new byte sequence.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s
    (length s - 1)); ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-iter"><code>Bytes.iter</code></a>, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-escaped" class="anchored"><a href="#val-escaped" class="anchor"></a><code><span><span class="keyword">val</span> escaped : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_opt" class="anchored"><a href="#val-index_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_opt : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_opt s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_opt" class="anchored"><a href="#val-rindex_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_opt : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_opt s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from_opt" class="anchored"><a href="#val-index_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_from_opt : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_from _opts i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>. <code>Bytes.index_opt s c</code> is equivalent to <code>Bytes.index_from_opt s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from_opt" class="anchored"><a href="#val-rindex_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from_opt : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_from_opt s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>. <code>rindex_opt s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_from" class="anchored"><a href="#val-contains_from" class="anchor"></a><code><span><span class="keyword">val</span> contains_from : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from
    s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rcontains_from" class="anchored"><a href="#val-rcontains_from" class="anchor"></a><code><span><span class="keyword">val</span> rcontains_from : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase_ascii" class="anchored"><a href="#val-uppercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_ascii : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase_ascii" class="anchored"><a href="#val-lowercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_ascii : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize_ascii" class="anchored"><a href="#val-capitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> capitalize_ascii : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize_ascii" class="anchored"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize_ascii : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = bytes</span></code></div><div class="spec-doc"><p>An alias for the type of byte sequences.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The comparison function for byte sequences, with the same specification as <code>Stdlib</code>.compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors <code>Stdlib</code>.Set.Make and <code>Stdlib</code>.Map.Make.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>The equality function for byte sequences.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0</li></ul></div></div></div></body></html>