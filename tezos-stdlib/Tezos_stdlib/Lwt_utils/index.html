<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_utils (tezos-stdlib.Tezos_stdlib.Lwt_utils)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">tezos-stdlib</a> &#x00BB; <a href="../index.html">Tezos_stdlib</a> &#x00BB; Lwt_utils</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_stdlib.Lwt_utils</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-never_ending" class="anchored"><a href="#val-never_ending" class="anchor"></a><code><span><span class="keyword">val</span> never_ending : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-worker" class="anchored"><a href="#val-worker" class="anchor"></a><code><span><span class="keyword">val</span> worker : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on_event:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Ended <span><span>| `Failed</span> of string</span> <span>| `Started</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span>
<span class="arrow">&#45;&gt;</span></span> <span>run:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>cancel:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>worker name ~on_event ~run ~cancel</code> internally calls <code>run ()</code> (which returns a promise <code>p</code>) and returns its own promise <code>work</code>. If <code>p</code> becomes fulfilled, then <code>work</code> also becomes fulfilled. If <code>p</code> becomes rejected then <code>cancel ()</code> is called and, once its promise is resolved, <code>work</code> is fulfilled. This gives the opportunity for the function <code>cancel</code> to clean-up some resources.</p><p>The function <code>on_event</code> is called at different times (start, failure, end) and is mostly meant as a logging mechanism but can also be used for other purposes such as synchronization between different workers.</p><p>If the promises returned by <code>on_event</code> or <code>cancel</code> raise an exception or become rejected, the exception/failure is simply ignored and the promise is treated as having resolved anyway.</p><p>Note that the promise <code>work</code> returned by the <code>worker</code> function is not cancelable. If you need to cancel the promise returned by <code>run</code>, you need to embed your own synchronization system within <code>run</code>. E.g.,</p><p><code>let p, r = Lwt.wait in
     let run () =
        let main = … in
        Lwt.pick [main ; p]
     in</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_s_n" class="anchored"><a href="#val-fold_left_s_n" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_s_n : <span>n:int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Evaluates fold_left_s on a batch of <code>n</code> elements and returns a pair containing the result of the first batch and the unprocessed elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dont_wait" class="anchored"><a href="#val-dont_wait" class="anchor"></a><code><span><span class="keyword">val</span> dont_wait : <span><span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dont_wait handler f</code> calls <code>f ()</code> and essentially ignores the returned promise. In particular it does not wait for the promise to resolve.</p><p><code>dont_wait</code> is meant as an alternative to <code>Lwt.async</code>. The former requires an explicit, local exception handler whereas the latter uses a global handler that is set by side-effects.</p><p>CAVEAT!</p><p>Note that, because of the semantics of execution in Lwt, the evaluation of <code>f ()</code> is immediate and some progress towards the resolution of the promise may happen immediately. Specifically, the progress towards the resolution of the promise <code>p</code> returned by <code>f ()</code> is made until the point where it yields. At that point, control comes back to the caller of <code>dont_wait</code> and continues. More concretely, consider the order of the side-effects in the following piece of code and in particular how the second side-effect in the order of execution is within the promise created by <code>dont_wait</code>.</p><p><code>side_effect (); (* first *)
     dont_wait
       (fun exc -&gt; ..)
       (fun () -&gt;
          side_effect (); (* second *)
          Lwt.pause () &gt;&gt;= fun () -&gt;
          side_effect (); (* delayed *)
          ..);
     side_effect (); (* third *)
    </code></p><p>If you want to delay any progress towards promise resolution being made (e.g., if you need strong guarantees about side-effects because you are in a critical section), then you need to add an explicit cooperation point. You can use <code>Lwt.pause</code> at the very beginning of the promise you pass to <code>dont_wait</code>: <code>dont_wait handler (fun () -&gt; Lwt.pause () &gt;&gt;= fun () -&gt; ..)</code>.</p><p>With this pattern, in the expression <code>dont_wait handler (fun () -&gt; Lwt.pause () &gt;&gt;= f)</code>, the anonymous lambda (<code>(fun () -&gt; …)</code>) is called immediately. However, when this call is evaluated, the call to <code>pause</code> immediately suspend progress towards the resolution of the promise, delaying the call <code>f ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map_s" class="anchored"><a href="#val-find_map_s" class="anchor"></a><code><span><span class="keyword">val</span> find_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Lwt version of <code>TzList.find_map</code></p></div></div></div></body></html>