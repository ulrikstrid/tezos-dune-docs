<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Circular_buffer (tezos-stdlib.Tezos_stdlib.Circular_buffer)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-stdlib</a> &#x00BB; <a href="../index.html">Tezos_stdlib</a> &#x00BB; Circular_buffer</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_stdlib.Circular_buffer</span></code></h1></header><div class="odoc-content"><p>This module implements a bufferisation abstraction to store temporary raw data chunks (as bytes) when chunks are read sequentially. The function write allows to store chunks in the buffer and the function read to read them from the buffer.</p><p>The global contract is that if we write consecutively <code>d1;d2</code> onto the buffer. Then we have to fully read d1 and d2, in that order.</p><p>This contract is not enforced by the library, it is the user responsability to respect it.</p><p>If the circular buffer is full, a new temporary buffer is allocated to store the chunk of data to be written.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of circular buffers</p></div></div><div class="odoc-spec"><div class="spec type" id="type-data" class="anchored"><a href="#type-data" class="anchor"></a><code><span><span class="keyword">type</span> data</span></code></div><div class="spec-doc"><p>An abstraction over a chunk of data written in the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?maxlength:int <span class="arrow">&#45;&gt;</span></span> <span>?fresh_buf_size:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a buffer of size maxlength. If the buffer is full, a buffer of size <code>fresh_buf_size</code> is allocated (by default `2` kb).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write" class="anchored"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span>maxlen:int <span class="arrow">&#45;&gt;</span></span> <span>fill_using:<span>(<span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-data">data</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>write ~maxlen ~fill_using:f buffer</code> calls <code>fill_using buf offset
   maxlen</code> where <code>buf</code> is a buffer that has room for <code>maxlen</code> data starting from <code>offset</code>.</p><p>Assumes that <code>fill_using</code> returns the exact amount of written bytes.</p><p>Behaviour is unspecified if <code>fill_using</code> writes more than <code>maxlen</code> data or lies on the number of written bytes.</p><p>It returns a data descriptor for the supposedly written chunk.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-data">data</a> <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>into:<span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span>offset:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-data">data</a> option</span></span></code></div><div class="spec-doc"><p><code>read data ~len ~into:buf buffer ~offset</code> blit <code>len</code> data from the <code>data</code> chunk. If <code>len</code> is not provided, blit all the data. If <code>len</code> is less than the amount of data available, it returns a new handler the the remainder.</p><p>Assumes that data has been produce by a write attempt in <code>buffer</code>. Assumes that ~len is lesser than <code>length data</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-data">data</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length data</code> returns the amount of avalaible bytes in <code>data</code></p></div></div></div></body></html>