<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_pipe (tezos-stdlib.Tezos_stdlib.Lwt_pipe)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-stdlib</a> &#x00BB; <a href="../index.html">Tezos_stdlib</a> &#x00BB; Lwt_pipe</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_stdlib.Lwt_pipe</span></code></h1></header><div class="odoc-content"><p>Data queues similar to the <code>Pipe</code> module in Jane Street's <code>Async</code> library. They are implemented with <code>Queue</code>s, limited in size, and use Lwt primitives for concurrent access.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of queues holding values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?size:<span>(int * <span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create ~size:(max_size, compute_size) ()</code> is an empty queue that can hold max <code>size</code> &quot;bytes&quot; of data, using <code>compute_size</code> to compute the number of &quot;bytes&quot; in a datum.</p><p>Note that you can use <code>size</code> to actually limit the size in byte (i.e., the memory foot-print of the structure (in this case, consider using <a href="#val-push_overhead"><code>push_overhead</code></a> to account for the boilerplate memory), but you can also use <code>size</code> to limit the foot-print of the structure for some other resource. E.g., you can spin up tasks in separate processes and limit the number of concurrently running processes.</p><p>Also note that the size bound is not inclusive. So with <code>size</code> set to <code>(2, fun _ -&gt; 1)</code> you can add one (1) element and then the pipe is full. (It is full because adding any other element would take the total size to <code>2</code> which is not strictly smaller than the <code>max_size</code> bound.)</p><p>If you do not provide a <code>size</code> argument, the queue is unbounded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>push q v</code> is a promise that is pending until there is enough space in <code>q</code> to accommodate <code>v</code>. When this happens <code>v</code> is added to the end of <code>q</code> and the promise resolves.</p><p>If there is enough space in <code>q</code> to accommodate <code>v</code> when the call is made, then the <code>v</code> is added immediately and an already resolved promise is returned.</p><p>Note that if several writes are stuck because the pipe is full. These writes will succeed in an order that might be different from the order the write attempts were made. Specifically, when pushing elements of different computed sizes, smaller pushes may be resolved earlier if enough space is freed.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is closed. More specifically, the promise is rejected with <code>Closed</code> if <code>q</code> is closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop" class="anchored"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop q</code> is a promise that is pending until there is an element in <code>q</code>. When this happens an element is removed and the promise is fulfilled with it.</p><p>If there is already an element in <code>q</code> when the call is made, the element is removed immediately and an already resolved promise is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <code>Closed</code> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_with_timeout" class="anchored"><a href="#val-pop_with_timeout" class="anchor"></a><code><span><span class="keyword">val</span> pop_with_timeout : <span><span>unit <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop_with_timeout t q</code> is a promise that behaves similarly to <code>pop q</code> except that it resolves with <code>None</code> if <code>t</code> resolves before there is an element in <code>q</code> to pop.</p><p>Note that there can be multiple promises that are awaiting for an element to pop from the queue. As a result, it is possible that <code>pop_with_timeout</code> is fulfilled with <code>None</code> even though values have been pushed to the <code>q</code>.</p><p><code>t</code> is canceled (i.e., it fails with <code>Canceled</code>) if an element is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <code>Closed</code> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_all" class="anchored"><a href="#val-pop_all" class="anchor"></a><code><span><span class="keyword">val</span> pop_all : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop_all q</code> is a promise that is pending until there is an element in <code>q</code>. When this happens, all the elements of <code>q</code> are removed and the promise is fulfilled with the list of elements (in the order in which they were inserted).</p><p>If there is already an element in <code>q</code> when the call is made, the elements are removed immediately and an already resolved promise is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <code>Closed</code> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_all_now" class="anchored"><a href="#val-pop_all_now" class="anchor"></a><code><span><span class="keyword">val</span> pop_all_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>pop_all_now q</code> removes and returns all the elements in <code>q</code> (in the order in which they were inserted). If <code>q</code> is empty, <code>[]</code> is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>peek q</code> returns the same value as <code>pop q</code> but does not remove the returned element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <code>Closed</code> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_all" class="anchored"><a href="#val-peek_all" class="anchor"></a><code><span><span class="keyword">val</span> peek_all : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>peek_all q</code> returns the elements in the <code>q</code> (oldest first), or <code>[]</code> if empty. It does not remove elements from <code>q</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">{!Closed}</span> <p>if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-push_now" class="anchored"><a href="#val-push_now" class="anchor"></a><code><span><span class="keyword">val</span> push_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>push_now q v</code> either</p><ul><li>adds <code>v</code> at the ends of <code>q</code> immediately and returns <code>true</code>, or</li><li>if <code>q</code> is full, returns <code>false</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_now" class="anchored"><a href="#val-pop_now" class="anchor"></a><code><span><span class="keyword">val</span> pop_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_now q</code> may remove and return the first element in <code>q</code> if <code>q</code> contains at least one element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length q</code> is the number of elements in <code>q</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty q</code> is <code>true</code> if <code>q</code> is empty, <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>empty q</code> is a promise that resolves when <code>q</code> becomes empty.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Closed" class="anchored"><a href="#exception-Closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Closed</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close q</code> the write-end of <code>q</code>:</p><p>* Future write attempts will fail with <a href="#exception-Closed"><code>Closed</code></a>. * If there are pending reads, they will become rejected with <a href="#exception-Closed"><code>Closed</code></a>. * Future read attempts will drain the data until there is no data left (at which point <a href="#exception-Closed"><code>Closed</code></a> may be raised).</p><p>The <code>close</code> function is idempotent.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-push_overhead" class="anchored"><a href="#val-push_overhead" class="anchor"></a><code><span><span class="keyword">val</span> push_overhead : int</span></code></div><div class="spec-doc"><p>The number of bytes used in the internal representation to hold an element in the queue.</p></div></div></div></body></html>