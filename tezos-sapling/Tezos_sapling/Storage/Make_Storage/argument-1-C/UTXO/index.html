<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>UTXO (tezos-sapling.Tezos_sapling.Storage.Make_Storage.1-C.UTXO)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">tezos-sapling</a> &#x00BB; <a href="../../../../index.html">Tezos_sapling</a> &#x00BB; <a href="../../../index.html">Storage</a> &#x00BB; <a href="../../index.html">Make_Storage</a> &#x00BB; <a href="../index.html">1-C</a> &#x00BB; UTXO</nav><h1>Module <code>1-C.UTXO</code></h1></header><dl><dt class="spec type" id="type-ciphertext"><a href="#type-ciphertext" class="anchor"></a><code><span class="keyword">type</span> ciphertext</code></dt><dd><p>Ciphertexts are encrypted information used to retrieve payments and can be decrypted with full keys or just ovk. They can be stored on-chain or transmitted off-chain from payer to recipient. *</p></dd></dl><dl><dt class="spec type" id="type-commitment"><a href="#type-commitment" class="anchor"></a><code><span class="keyword">type</span> commitment</code></dt><dd><p>A commitment is the equivalent of a transaction output, with the important difference of not leaking any information. Must be stored on chain. *</p></dd></dl><dl><dt class="spec type" id="type-cv"><a href="#type-cv" class="anchor"></a><code><span class="keyword">type</span> cv</code></dt><dd><p>Commitment value. The value of a transaction output is committed (Pedersen's commitment) separately. *</p></dd></dl><dl><dt class="spec type" id="type-hash"><a href="#type-hash" class="anchor"></a><code><span class="keyword">type</span> hash</code></dt><dt class="spec type" id="type-nullifier"><a href="#type-nullifier" class="anchor"></a><code><span class="keyword">type</span> nullifier</code></dt><dd><p>Nullifiers are used to invalidated a commitment, that is marking it as spent. However they can't be linked to the commitment that they invalidate. Nullifiers are derived from a commitment and a secret key using a pseudo random function. *</p></dd></dl><dl><dt class="spec type" id="type-rk"><a href="#type-rk" class="anchor"></a><code><span class="keyword">type</span> rk</code></dt><dd><p>Randomised signature keys. All inputs are signed with a randomised version of a secret key. *</p></dd></dl><dl><dt class="spec type" id="type-spend_proof"><a href="#type-spend_proof" class="anchor"></a><code><span class="keyword">type</span> spend_proof</code></dt><dd><p>Zero knowledge proofs needed to spend a transaction outputs. See spec section 4.15 *</p></dd></dl><dl><dt class="spec type" id="type-spend_sig"><a href="#type-spend_sig" class="anchor"></a><code><span class="keyword">type</span> spend_sig</code></dt><dd><p>Signature needed to spend tokens. Computed with a randomised version of the secret key and verifies under a randomised version of the public key. Signs a hash of an input concatenated with an optional anti-replay string. *</p></dd></dl><dl><dt class="spec type" id="type-output_proof"><a href="#type-output_proof" class="anchor"></a><code><span class="keyword">type</span> output_proof</code></dt><dd><p>Zero-knowledge proof needed to create money. See spec section 4.15 *</p></dd></dl><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code><code> = </code><code>{</code><table class="record"><tr id="type-input.cv" class="anchored"><td class="def field"><a href="#type-input.cv" class="anchor"></a><code>cv : <a href="index.html#type-cv">cv</a>;</code></td></tr><tr id="type-input.nf" class="anchored"><td class="def field"><a href="#type-input.nf" class="anchor"></a><code>nf : <a href="index.html#type-nullifier">nullifier</a>;</code></td></tr><tr id="type-input.rk" class="anchored"><td class="def field"><a href="#type-input.rk" class="anchor"></a><code>rk : <a href="index.html#type-rk">rk</a>;</code></td></tr><tr id="type-input.proof_i" class="anchored"><td class="def field"><a href="#type-input.proof_i" class="anchor"></a><code>proof_i : <a href="index.html#type-spend_proof">spend_proof</a>;</code></td></tr><tr id="type-input.signature" class="anchored"><td class="def field"><a href="#type-input.signature" class="anchor"></a><code>signature : <a href="index.html#type-spend_sig">spend_sig</a>;</code></td></tr></table><code>}</code></dt><dd><p>Contains the necessary information to spend tokens (except the root which we include in the transaction). *</p></dd></dl><dl><dt class="spec value" id="val-input_encoding"><a href="#val-input_encoding" class="anchor"></a><code><span class="keyword">val</span> input_encoding : <span><a href="index.html#type-input">input</a> Data_encoding.t</span></code></dt></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type</span> output</code><code> = </code><code>{</code><table class="record"><tr id="type-output.cm" class="anchored"><td class="def field"><a href="#type-output.cm" class="anchor"></a><code>cm : <a href="index.html#type-commitment">commitment</a>;</code></td></tr><tr id="type-output.proof_o" class="anchored"><td class="def field"><a href="#type-output.proof_o" class="anchor"></a><code>proof_o : <a href="index.html#type-output_proof">output_proof</a>;</code></td></tr><tr id="type-output.ciphertext" class="anchored"><td class="def field"><a href="#type-output.ciphertext" class="anchor"></a><code>ciphertext : <a href="index.html#type-ciphertext">ciphertext</a>;</code></td></tr></table><code>}</code></dt><dd><p>Contains the necessary information to create tokens. *</p></dd></dl><dl><dt class="spec value" id="val-output_encoding"><a href="#val-output_encoding" class="anchor"></a><code><span class="keyword">val</span> output_encoding : <span><a href="index.html#type-output">output</a> Data_encoding.t</span></code></dt></dl><dl><dt class="spec type" id="type-binding_sig"><a href="#type-binding_sig" class="anchor"></a><code><span class="keyword">type</span> binding_sig</code></dt><dd><p>Ties a transaction to a balance (difference between the tokens created and spent). Proves with the commitment values that sum of values of inputs minus sums of values of output equals balance. *</p></dd></dl><dl><dt class="spec value" id="val-binding_sig_encoding"><a href="#val-binding_sig_encoding" class="anchor"></a><code><span class="keyword">val</span> binding_sig_encoding : <span><a href="index.html#type-binding_sig">binding_sig</a> Data_encoding.t</span></code></dt></dl><dl><dt class="spec type" id="type-transaction"><a href="#type-transaction" class="anchor"></a><code><span class="keyword">type</span> transaction</code><code> = </code><code>{</code><table class="record"><tr id="type-transaction.inputs" class="anchored"><td class="def field"><a href="#type-transaction.inputs" class="anchor"></a><code>inputs : <span><a href="index.html#type-input">input</a> list</span>;</code></td></tr><tr id="type-transaction.outputs" class="anchored"><td class="def field"><a href="#type-transaction.outputs" class="anchor"></a><code>outputs : <span><a href="index.html#type-output">output</a> list</span>;</code></td></tr><tr id="type-transaction.binding_sig" class="anchored"><td class="def field"><a href="#type-transaction.binding_sig" class="anchor"></a><code>binding_sig : <a href="index.html#type-binding_sig">binding_sig</a>;</code></td></tr><tr id="type-transaction.balance" class="anchored"><td class="def field"><a href="#type-transaction.balance" class="anchor"></a><code>balance : int64;</code></td></tr><tr id="type-transaction.root" class="anchored"><td class="def field"><a href="#type-transaction.root" class="anchor"></a><code>root : <a href="index.html#type-hash">hash</a>;</code></td></tr></table><code>}</code></dt><dd><p>Transaction that is sent to a verifier. The root corresponds to a merkle tree where the inputs are present. Even if this root can in principle be very old, a verifier may keep only the last n known roots considering anything older as invalid. The memo_size field is checked at encoding and encoding to be the real memo size of all outputs. A transaction leaks the balance between inputs and outputs and the number of inputs and outputs. Note that the number of inputs is limited to 5208 and number of outputs to 2019, by a check in the encoding. This is important to avoid invalidating a proof over the balance as described in section 4.12 of the spec.</p></dd></dl><dl><dt class="spec value" id="val-transaction_encoding"><a href="#val-transaction_encoding" class="anchor"></a><code><span class="keyword">val</span> transaction_encoding : <span><a href="index.html#type-transaction">transaction</a> Data_encoding.t</span></code></dt><dd><p>The encoding enforces the limits on number of inputs and outputs.</p></dd></dl><dl><dt class="spec value" id="val-max_amount"><a href="#val-max_amount" class="anchor"></a><code><span class="keyword">val</span> max_amount : int64</code></dt><dd><p>Maximum amount of shielded tokens. This value is imposed by librustzcash. *</p></dd></dl><dl><dt class="spec value" id="val-valid_amount"><a href="#val-valid_amount" class="anchor"></a><code><span class="keyword">val</span> valid_amount : int64 <span>&#45;&gt;</span> bool</code></dt></dl></div></body></html>