<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (tezos-lwt-result-stdlib.Bare_sigs__Seq_s.S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">tezos-lwt-result-stdlib</a> &#x00BB; <a href="../index.html">Bare_sigs__Seq_s</a> &#x00BB; S</nav><h1>Module type <code>Bare_sigs__Seq_s.S</code></h1><p>The <code>S</code> signature is similar to <span class="xref-unresolved" title="unresolved reference to &quot;Seq.S&quot;"><code>Seq</code>.S</span> except that suspended nodes are wrapped in a promise.</p><p>This allows some additional traversors (<code>map_s</code>, etc.) to be applied lazily.</p><p>The functions <code>of_seq</code> and <code>of_seq_s</code> allow conversion from vanilla sequences.</p></header><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> <span>+'a node</span></code><code> = </code><table class="variant"><tr id="type-node.Nil" class="anchored"><td class="def constructor"><a href="#type-node.Nil" class="anchor"></a><code>| </code><code><span class="constructor">Nil</span></code></td></tr><tr id="type-node.Cons" class="anchored"><td class="def constructor"><a href="#type-node.Cons" class="anchor"></a><code>| </code><code><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></td></tr></table></dt><dd><p>This is similar to <code>S.t</code> but the suspended node is a promise.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">and</span> <span>'a t</span></code><code> = unit <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-node">node</a></span> Lwt.t</span></code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> is a sequence with no elements.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return x</code> is a sequence with the single element <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-return_s"><a href="#val-return_s" class="anchor"></a><code><span class="keyword">val</span> return_s : <span><span class="type-var">'a</span> Lwt.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return_s p</code> is a sequence with the value the promise <code>p</code> resolves to as its single element.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cons x s</code> is the sequence containing <code>x</code> followed by <code>s</code>. It is a whole sequence if <code>s</code> is.</p></dd></dl><dl><dt class="spec value" id="val-cons_s"><a href="#val-cons_s" class="anchor"></a><code><span class="keyword">val</span> cons_s : <span><span class="type-var">'a</span> Lwt.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cons_s p s</code> is the sequence containing the value the promise <code>p</code> resolves to, followed by <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>append s1 s2</code> is a sequence <code>s</code> containing the elements of <code>s1</code> followed by the elements of <code>s2</code>.</p></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> Lwt.t</span></code></dt><dd><p><code>first s</code> resolves to <code>None</code> if <code>s</code> is empty (and its suspended node resolves), it resolves to <code>Some x</code> where <code>x</code> is the first element of <code>s</code>, it does not resolve if the promised node of <code>s</code> doesn't.</p><p>Note that <code>first</code> forces the first element of the sequence, which can have side-effects or be computationally expensive. Consider, e.g., the case where <code>s = filter (fun …) s'</code>: <code>first s</code> can force multiple of the values from <code>s'</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-fold_left"><code>fold_left</code></a> but applies to Lwt-suspended sequences. Because the nodes are suspended in promises, traversing may yield and, consequently, the function <code>fold_left</code> returns a promise.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_e"><a href="#val-fold_left_e" class="anchor"></a><code><span class="keyword">val</span> fold_left_e : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> Stdlib.result</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-fold_left"><code>fold_left</code></a> but wraps the traversal in <code>result</code>. The traversal is interrupted if one of the step returns an <code>Error _</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_s"><a href="#val-fold_left_s" class="anchor"></a><code><span class="keyword">val</span> fold_left_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-fold_left"><code>fold_left</code></a> but the folder is within Lwt.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_es"><a href="#val-fold_left_es" class="anchor"></a><code><span class="keyword">val</span> fold_left_es : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-fold_left"><code>fold_left</code></a> but the folder is within result-Lwt. Traversal is interrupted if one of the step resolves to an <code>Error _</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>iter f s</code> applies <code>f</code> to each element of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter_e"><a href="#val-iter_e" class="anchor"></a><code><span class="keyword">val</span> iter_e : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'trace</span>)</span> Stdlib.result</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-iter"><code>iter</code></a> but wraps the iteration in <code>result</code>. The iteration is interrupted if one of the steps returns an <code>Error _</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter_s"><a href="#val-iter_s" class="anchor"></a><code><span class="keyword">val</span> iter_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-iter"><code>iter</code></a> but wraps the iteration in <code>Lwt</code>. Each step of the iteration is started after the previous one is resolved.</p></dd></dl><dl><dt class="spec value" id="val-iter_es"><a href="#val-iter_es" class="anchor"></a><code><span class="keyword">val</span> iter_es : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-iter"><code>iter</code></a> but wraps the iteration in <code>result Lwt.t</code>. Each step of the iteration is started after the previous one resolved. The iteration is interrupted if one of the promise is rejected of fulfilled with an <code>Error _</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter_ep"><a href="#val-iter_ep" class="anchor"></a><code><span class="keyword">val</span> iter_ep : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> Stdlib.result</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(unit, <span><span class="type-var">'trace</span> list</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-iter"><code>iter</code></a> but wraps the iteration in <code>result Lwt.t</code>. The steps of the iteration are started concurrently: one iteration starts as soon as a node becomes resolved. The promise <code>iter_ep</code> resolves once all the promises of the traversal resolve. At this point it either:</p><ul><li>is rejected if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Error _</code> if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Ok ()</code> if all the promises are.</li></ul></dd></dl><dl><dt class="spec value" id="val-iter_p"><a href="#val-iter_p" class="anchor"></a><code><span class="keyword">val</span> iter_p : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Similar to <a href="index.html#val-iter"><code>iter</code></a> but wraps the iteration in <code>Lwt</code>. The steps of the iteration are started concurrently: one iteration is started as soon as the node becomes resolved. The promise <code>iter_p f s</code> is resolved only once all the promises of the iteration are. At this point it is either fulfilled if all promises are, or rejected if at least one of them is.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map_s"><a href="#val-map_s" class="anchor"></a><code><span class="keyword">val</span> map_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-filter_s"><a href="#val-filter_s" class="anchor"></a><code><span class="keyword">val</span> filter_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>bool Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Similar to <a href="index.html#val-filter"><code>filter</code></a> but wraps the transformation in <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.t&quot;"><code>Lwt</code>.t</span>. Each test of the predicate is done sequentially, only starting once the previous one has resolved.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-filter_map_s"><a href="#val-filter_map_s" class="anchor"></a><code><span class="keyword">val</span> filter_map_s : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> option</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Similar to <a href="index.html#val-filter_map"><code>filter_map</code></a> but within <code>Lwt.t</code>. Not lazy and not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-unfold_s"><a href="#val-unfold_s" class="anchor"></a><code><span class="keyword">val</span> unfold_s : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span class="type-var">'a</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-of_seq_s"><a href="#val-of_seq_s" class="anchor"></a><code><span class="keyword">val</span> of_seq_s : <span><span><span class="type-var">'a</span> Lwt.t</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt></dl></div></body></html>