<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwtreslib (tezos-lwt-result-stdlib.Tezos_lwt_result_stdlib.Lwtreslib)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-lwt-result-stdlib</a> &#x00BB; <a href="../index.html">Tezos_lwt_result_stdlib</a> &#x00BB; Lwtreslib</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_lwt_result_stdlib.Lwtreslib</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#lwtreslib:-the-lwt--and-result-aware-stdlib-complement">Lwtreslib: the Lwt- and result-aware Stdlib complement</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#semantic">Semantic</a><ul><li><a href="#semantic-of-vanilla-functions">Semantic of vanilla-functions</a></li><li><a href="#semantic-of-lwt-aware-functions">Semantic of Lwt-aware functions</a></li><li><a href="#semantic-of-result-aware-functions">Semantic of result-aware functions</a></li><li><a href="#semantic-of-lwt-result-aware-functions">Semantic of Lwt-result-aware functions</a></li><li><a href="#a-note-on-seq">A note on <code>Seq</code></a></li><li><a href="#traced"><code>Traced</code></a></li></ul></li><li><a href="#monad-helpers">Monad helpers</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#withexceptions"><code>WithExceptions</code></a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="lwtreslib:-the-lwt--and-result-aware-stdlib-complement"><a href="#lwtreslib:-the-lwt--and-result-aware-stdlib-complement" class="anchor"></a>Lwtreslib: the Lwt- and result-aware Stdlib complement</h2><p>Lwtreslib (or Lwt-result-stdlib) is a library to complement the OCaml's Stdlib in software projects that make heavy use of Lwt and the result type.</p><h3 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h3><p>Lwtreslib aims to</p><ul><li>Replace exception-raising functions with exception-safe one. E.g., functions that may raise <code>Not_found</code> in the Stdlib are shadowed by functions that return an <code>option</code>.</li><li>Provide an extensive set of Lwt-, result- and Lwt-result-traversors for the common data-types of the Stdlib. E.g., <code>List</code>.map is available alongside <code>List.map_s</code> for Lwt sequential traversal, <code>List.map_e</code> for result traversal, etc.</li><li>Provide a uniform semantic, especially regarding error management. E.g., all sequential traversal functions have the same fail-early semantic, whereas all concurrent traversal functions have the same best-effort semantic.</li><li>Provide good documentation.</li></ul><h3 id="semantic"><a href="#semantic" class="anchor"></a>Semantic</h3><p>The semantic of the functions exported by Lwtreslib is uniform and predictable. This applies to the Stdlib-like functions, the Lwt-aware functions, the result-aware functions, and the Lwt-and-result-aware functions.</p><h4 id="semantic-of-vanilla-functions"><a href="#semantic-of-vanilla-functions" class="anchor"></a>Semantic of vanilla-functions</h4><p>Functions that have the same signature as their Stdlib's counterpart have the same semantic.</p><p>Functions exported by Lwtreslib do not raise exceptions. (With the exception of the functions exported by the <code>WithExceptions</code> module.) If a function raises an exception in the Stdlib, its type is changed in Lwtreslib. In general the following substitution apply:</p><ul><li>Functions that may raise <code>Not_found</code> (e.g., <code>List.find</code>) return an <code>option</code> instead.</li><li>Functions that may fail because of indexing errors (e.g., <code>List.nth</code>, <code>List.hd</code>, etc.) also return an <code>option</code> instead.</li><li>Functions that may raise <code>Invalid_argument</code> (e.g., <code>List.iter2</code>) return a <code>result</code> type instead. The take an additional argument indicating what <code>Error_</code> to return instead of the exception.</li></ul><h4 id="semantic-of-lwt-aware-functions"><a href="#semantic-of-lwt-aware-functions" class="anchor"></a>Semantic of Lwt-aware functions</h4><p>Lwtreslib exports Lwt-aware functions for all traversal functions of the Stdlib.</p><p>Functions with the <code>_s</code> suffix traverse their underlying collection sequentially, waiting for the promise associated to one element to resolve before processing to the next element.</p><p>Functions with the <code>_p</code> suffix traverse their underlying collection concurrently, creating promises for all the elements and then waiting for all of them to resolve. The &quot;p&quot; in the <code>_p</code> suffix is for compatibility with Lwt and in particular <code>Lwt_list</code>. The mnemonic is &quot;parallel&quot; even though there is not parallelism, only concurrency.</p><p>These <code>_s</code>- and <code>_p</code>-suffixed functions are semantically identical to their Lwt counterpart when it is available. Most notably, <code>Lwtreslib.List</code> is a strict superset of <code>Lwt_list</code>.</p><h4 id="semantic-of-result-aware-functions"><a href="#semantic-of-result-aware-functions" class="anchor"></a>Semantic of result-aware functions</h4><p>Lwtreslib exports result-aware functions for all the traversal functions of the Stdlib. These function allow easy manipulation of <code>('a, 'e) result</code> values.</p><p>Functions with the <code>_e</code> suffix traverse their underlying collection whilst wrapping the accumulator/result in a <code>result</code>. These functions have a fail-early semantic: if one of the step returns an <code>Error _</code>, then the whole traversal is interrupted and returns the same <code>Error _</code>.</p><h4 id="semantic-of-lwt-result-aware-functions"><a href="#semantic-of-lwt-result-aware-functions" class="anchor"></a>Semantic of Lwt-result-aware functions</h4><p>Lwtreslib exports Lwt-result-aware functions for all the traversal functions of the Stdlib. These function allow easy manipulation of <code>!('a, 'e) result Lwt.t</code> -- i.e., promises that may fail.</p><p>Functions with the <code>_es</code> suffix traverse their underlying collection sequentially (like <code>_s</code> functions) whilst wrapping the accumulator/result in a <code>result</code> (like <code>_e</code> functions). These functions have a fail-early semantic: if one of the step returns a promise that resolves to an <code>Error _</code>, then the whole traversal is interrupted and the returned promise resolves to the same <code>Error _</code>.</p><p>Functions with the <code>_ep</code> suffix traverse their underlying collection concurrently (like <code>_p</code> functions) whilst wrapping the accumulator/result in a <code>result</code> (like <code>_e</code> functions). These functions have a best-effort semantic: if one of the step returns a promise that resolves to an <code>Error _</code>, the other promises are left to resolve; once all the promises have resolved, then the returned promise resolves with an <code>Error _</code> that carries all the other errors in a list. It is up to the user to convert this list to a more manageable type if needed.</p><h4 id="a-note-on-seq"><a href="#a-note-on-seq" class="anchor"></a>A note on <code>Seq</code></h4><p>The <code>Seq</code> module exports a type that suspends nodes under a closure. Consequently, some interactions with result, Lwt, and result-Lwt is not possible. E.g., <code>map</code>ping can be either lazy or within Lwt but not both: <code>Seq.map_s</code> would have type <code>('a -&gt; 'b Lwt.t) -&gt; 'a t -&gt; 'b t Lwt.t</code> where the returned promise forces the whole sequence (and never resolves on infinite sequences).</p><p>In Lwtreslib, <code>Seq</code> does not provide these additional traversors that would force the sequence simply due to the bad interaction of the Monads and the type of sequences. Instead, Lwtreslib provides variants of <code>Seq</code> called <code>Seq_e</code>, <code>Seq_s</code>, and <code>Seq_es</code> where the combination with the monad is baked into the sequence type itself.</p><p>If you want to map a sequnence using an Lwt-returning function, you should do the following: <code>Seq_s.map_s f (Seq_s.of_seq s)</code>. Note that this returns a <code>Seq_s.t</code> sequence so further transformations will be within <code>Seq_s</code> and not within <code>Seq</code>. Once in a monad, you stay in the monad.</p><h4 id="traced"><a href="#traced" class="anchor"></a><code>Traced</code></h4><p>The <a href="Traced/index.html"><code>Traced</code></a> module offers a small wrapper around Lwtreslib. This wrapper is intended to ease the use of <code>_ep</code> functions. It does so by introducing a trace data-type: a structured collection of errors.</p><p>This trace data-type is used to collapse the types <code>'e</code> and <code>'e list</code> of errors. Indeed, without this collapse, chaining <code>_ep</code> together or chaining <code>_ep</code> with <code>_es</code> functions requires significant boilerplate to flatten lists, to listify single errors, etc. Need for boilerplate mostly vanishes when using the <code>Traced</code> wrapper.</p><h3 id="monad-helpers"><a href="#monad-helpers" class="anchor"></a>Monad helpers</h3><p>Lwtreslib also exports monadic operators (binds, return, etc.) for the Lwt-monad, the result-monad, and the combined Lwt-result-monad.</p><h3 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h3><p>If at all possible, avoid exceptions.</p><p>If possible, avoid exceptions.</p><p>If you use exceptions, here are a few things to keep in mind:</p><p>The <code>_p</code> functions are semantically equivalent to Lwt's. This means that some exceptions are dropped. Specifically, when more than one promise raises an exception in a concurrent traversor, only one is passed on to the user, the others are silently ignored.</p><p>Use <code>raise</code> (rather than <code>Lwt.fail</code>) when within an Lwt callback.</p><h3 id="withexceptions"><a href="#withexceptions" class="anchor"></a><code>WithExceptions</code></h3><p>The <code>WithExceptions</code> module is there for convenience in non-production code and for the specific cases where it is guaranteed not to raise an exception.</p><p>E.g., it is intended for removing the <code>option</code> boxing in cases where the invariant is guaranteed by construction:</p><pre><code>(** Return an interval of integers, from 0 to its argument (if positive)
    or from its argument to 0 (otherwise). *)
let steps stop =
   if stop = 0 then
      []
   else if stop &gt; 0 then
      List.init ~when_negative_length:() Fun.id
      |&gt; WithExceptions.Option.get ~loc:__LOC__
   else
      let stop = Int.neg stop in
      List.init ~when_negative_length:() Int.neg
      |&gt; WithExceptions.Option.get ~loc:__LOC__</code></pre><div class="odoc-spec"><div class="spec module" id="module-Bare" class="anchored"><a href="#module-Bare" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Bare/index.html">Bare</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Traced" class="anchored"><a href="#module-Traced" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Traced/index.html">Traced</a></span><span> (<a href="Traced/argument-1-Trace/index.html">Trace</a> : <a href="../../Traced_sigs/Trace/module-type-S/index.html">Traced_sigs.Trace.S</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Traced</code> is a functor to generate an advanced combined-monad replacements for parts of the Stdlib. The generated module is similar to <code>Bare</code> with the addition of traces: structured collections of errors.</p></div></div></div></body></html>