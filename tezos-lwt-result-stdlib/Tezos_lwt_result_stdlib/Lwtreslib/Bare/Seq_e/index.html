<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Seq_e (tezos-lwt-result-stdlib.Tezos_lwt_result_stdlib.Lwtreslib.Bare.Seq_e)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../index.html">tezos-lwt-result-stdlib</a> &#x00BB; <a href="../../../index.html">Tezos_lwt_result_stdlib</a> &#x00BB; <a href="../../index.html">Lwtreslib</a> &#x00BB; <a href="../index.html">Bare</a> &#x00BB; Seq_e</nav><header class="odoc-preamble"><h1>Module <code><span>Bare.Seq_e</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e) t</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-node">node</a></span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>This is similar to <code>Stdlib</code>.Seq.S<code>.t</code> but the suspended node is a result.</p><p>Consequently, the sequence of elements may be interrupted by an error. Specifically, there are two possible kinds of sequences:</p><ul><li><em>interrupted sequences</em> where one of the suspended nodes is not returned and an <code>Error _</code> is produced instead, and</li><li><em>whole sequences</em> where all the suspended nodes are actually returned inside an <code>Ok _</code>.</li></ul><p>All the traversors below treat sequence interruption as an error that is returned as is.</p><p>Also note that nodes are suspended by a continuation rather than a lazy block. As a result, different traversals of the same sequence can lead to repeated evaluations of the same elements, or distinct sets of elements, or even a different kind of sequence. E.g., if a suspended sequence fails or succeeds depending on the content of a reference.</p><p>This is not recommended. You should use deterministic sequences that do not depend on state. Or you should use one-shot sequences that are used once and then never again. The documentation of this module is written assuming you adhere to these constraints.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-node" class="anchored"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">and</span> <span>(+'a, 'e) node</span></span><span> = </span></code><table><tr id="type-node.Nil" class="anchored"><td class="def variant constructor"><a href="#type-node.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span></span></code></td></tr><tr id="type-node.Cons" class="anchored"><td class="def variant constructor"><a href="#type-node.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A whole sequence of zero elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return x</code> is a whole sequence containing the single element <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return_e" class="anchored"><a href="#val-return_e" class="anchor"></a><code><span><span class="keyword">val</span> return_e : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return_e (Ok x)</code> is a whole sequence containing the single element <code>x</code>. <code>return_e (Error e)</code> is a sequence immediately interrupted by the error <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interrupted" class="anchored"><a href="#val-interrupted" class="anchor"></a><code><span><span class="keyword">val</span> interrupted : <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>interrupted e</code> is a sequence immediately interrupted by the error <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nil" class="anchored"><a href="#val-nil" class="anchor"></a><code><span><span class="keyword">val</span> nil : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p><code>nil</code> is the node forming the empty sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons x s</code> is the sequence containing <code>x</code> followed by <code>s</code>. It is a whole sequence if <code>s</code> is.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons_e" class="anchored"><a href="#val-cons_e" class="anchor"></a><code><span><span class="keyword">val</span> cons_e : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons_e (Ok x) s</code> is the sequence containing <code>x</code> followed by <code>s</code>. It is a whole sequence if <code>s</code> is.</p><p><code>cons_e (Error e) s</code> is a sequence immediately interrupted by <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>append s1 s2</code> is a sequence <code>s</code>. If <code>s1</code> is a whole sequence then <code>s</code> is composed of all the elements of <code>s1</code> followed by <code>s2</code>. If <code>s1</code> is an interrupted sequence then <code>s</code> is indistinguishable from <code>s1</code>.</p><p><code>s</code> is a whole sequence if both <code>s1</code> and <code>s2</code> are.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> option</span></span></code></div><div class="spec-doc"><p><code>first s</code> is <code>None</code> if <code>s</code> is empty, it is <code>Some (Error e)</code> if <code>s</code> is immediately interrupted by <code>e</code>, it is <code>Some (Ok x)</code> where <code>x</code> is the first element of <code>s</code> otherwise.</p><p>Note that <code>first</code> forces the first element of the sequence, which can have side-effects or be computationally expensive. Consider, e.g., the case where <code>s = filter (fun …) s'</code>: <code>first s</code> can force multiple of the values from <code>s'</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_left f init seq</code> is</p><ul><li>if <code>seq</code> is a whole sequence, then <code>Ok x</code> where <code>x</code> is the result of folding <code>f</code> over all the elements of <code>seq</code> starting with <code>init</code>, or</li><li>if <code>seq</code> is interrupted by <code>Error e</code>, then <code>Error e</code>.</li></ul><p>Note that, as with all other traversors below, if the sequence is interrupted, all the side-effects of <code>f</code> on the successful prefix of <code>seq</code> have already been applied before the traversal returns <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_e" class="anchored"><a href="#val-fold_left_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_left_e f init seq</code> folds <code>f</code> over the elements of <code>seq</code> with an accumulator set at <code>init</code>. It stops traversal (returning <code>Error _</code>) if <code>f</code> returns an <code>Error _</code> or if the sequence is interrupted. Otherwise it returns <code>Ok _</code>.</p><p>It is the responsibility of the caller to differentiate between errors from the function and errors from the sequence. The function <a href="#val-map_error"><code>map_error</code></a> may come in handy. E.g.,</p><pre><code>fold_left_e
  (fun acc item -&gt;
    f acc item |&gt; Result.map_error (fun e -&gt; `Traverse e))
  init
  (s |&gt; map_error (fun e -&gt; `Interrupt e))</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_s" class="anchored"><a href="#val-fold_left_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_s f init seq</code> is a promise that resolves to</p><ul><li>if <code>seq</code> is a whole sequence, then <code>Ok x</code> where <code>x</code> is the result of folding <code>f</code> over all the elements of <code>seq</code> starting with <code>init</code>, or</li><li>if <code>seq</code> is interrupted by <code>Error e</code>, then <code>Error e</code>.</li></ul><p>Note that if it returns <code>Error _</code>, the side-effects of <code>f</code> on previous elements have already been applied anyway.</p><p>The elements are traversed sequentially. Specifically, a node's suspension is called only when the <code>f</code>-promise of the previous node has resolved. Thus, there might be yielding in between suspensions being called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_es" class="anchored"><a href="#val-fold_left_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_es f init seq</code> is a promise that resolves to</p><ul><li>if <code>seq</code> is a whole sequence and <code>f</code>-promises always resolve successfully, then the result of folding <code>f</code> over all the elements of <code>seq</code> starting with <code>init</code>,</li><li>otherwise, <code>Error _</code> with the error that interrupts the sequence or with an error returned by <code>f</code>, whichever happens first.</li></ul><p>The elements are traversed sequentially. Specifically, a node's suspension is called only when the <code>f</code>-promise of the previous node has resolved. Thus, there might be yielding in between suspensions being called.</p><p>See <a href="#val-fold_left_e"><code>fold_left_e</code></a> for a warning about traversal and interruption errors being indistinguishable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>iter f seq</code> is <code>fold_left (fun () x -&gt; f x) () seq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_e" class="anchored"><a href="#val-iter_e" class="anchor"></a><code><span><span class="keyword">val</span> iter_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>iter_e f seq</code> is <code>fold_left_e (fun () x -&gt; f x) () seq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_s" class="anchored"><a href="#val-iter_s" class="anchor"></a><code><span><span class="keyword">val</span> iter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_s f seq</code> is <code>fold_left_s (fun () x -&gt; f x) () seq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_es" class="anchored"><a href="#val-iter_es" class="anchor"></a><code><span><span class="keyword">val</span> iter_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_es f seq</code> is <code>fold_left_es (fun () x -&gt; f x) () seq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_p" class="anchored"><a href="#val-iter_p" class="anchor"></a><code><span><span class="keyword">val</span> iter_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_p f seq</code> is a promise <code>p</code>.</p><ul><li>If <code>seq</code> is a whole sequence, then <code>p</code> resolves to <code>Ok ()</code> once all the promises created by <code>f</code> on the elements of <code>seq</code> have resolved.</li><li>If <code>seq</code> is interrupted by <code>Error e</code>, then <code>p</code> resolves to <code>Error e</code> once all the promises created by <code>f</code> on the elements of the successful prefix of <code>seq</code> have resolved.</li></ul><p>Note that the behaviour for interrupted sequences is in line with the best-effort semantic of Lwtreslib.</p></div></div><p>There is no <code>iter_ep</code> in <code>Bare</code>. The reason is that there can be two sources of failures and there is no satisfying way to combine failures for the caller.</p><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f seq</code> is a sequence <code>feq</code>.</p><ul><li>If <code>seq</code> is a whole sequence, then <code>feq</code> is a whole sequence where the elements are the result of the application of <code>f</code> on the elements of <code>seq</code>.</li><li>If <code>seq</code> is an interrupted sequence, then <code>feq</code> is a sequence interrupted by <code>Error e</code> where the elements of the successful prefix are the result of the application of <code>f</code> on the elements of the successful prefix of <code>seq</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_error" class="anchored"><a href="#val-map_error" class="anchor"></a><code><span><span class="keyword">val</span> map_error : <span><span>(<span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'f</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'f</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_error f seq</code> is a sequence <code>feq</code>.</p><ul><li>If <code>seq</code> is a whole sequence, then <code>feq</code> is the same whole sequence.</li><li>If <code>seq</code> is an interrupted sequence, then <code>feq</code> is a sequence interrupted by <code>Error (f e)</code> where the elements of the successful prefix are the elements of the successful prefix of <code>seq</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_e" class="anchored"><a href="#val-map_e" class="anchor"></a><code><span><span class="keyword">val</span> map_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_e f seq</code> is a sequence <code>feq</code>.</p><ul><li>If <code>seq</code> is a whole sequence and if <code>f</code> is successful on all the elements of <code>seq</code>, then <code>feq</code> is a whole sequence where the elements are <code>x</code> where <code>Ok x</code> is the result of the application of <code>f</code> on the elements of <code>seq</code>.</li><li>Otherwise <code>feq</code> is a sequence composed of elements of <code>seq</code> mapped by <code>f</code> and interrupted by <code>f</code> returning <code>Error</code> or by <code>seq</code>'s interruption (whichever comes first).</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f s</code> is a sequence of the same kind as <code>s</code> with only the elements for which <code>f</code> returns <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_e" class="anchored"><a href="#val-filter_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_e f s</code> is a sequence that is interrupted like <code>s</code> or by <code>f</code> being unsuccessful (whichever comes first) or whole (if neither cases apply). Whichever is the case, the elements of the resulting sequence are the elements of <code>s</code> for which <code>f</code> returns <code>Ok true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f s</code> is a sequence of the same kind as <code>s</code> where the elements are transformed by <code>f</code> (when it returns <code>Some _</code>) or dropped (when it returns <code>None</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map_e" class="anchored"><a href="#val-filter_map_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map_e f s</code> is a sequence that is whole or that is interrupted in the same way as <code>s</code> (if it is) or that is interrupted by <code>f</code> (if it happens). Whichever the case, the elements of the sequence or the successful prefix thereof are transformed by <code>f</code> (when it returns <code>Some _</code>) or dropped (when it returns <code>None</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_e" class="anchored"><a href="#val-unfold_e" class="anchor"></a><code><span><span class="keyword">val</span> unfold_e : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq_e" class="anchored"><a href="#val-of_seq_e" class="anchor"></a><code><span><span class="keyword">val</span> of_seq_e : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div></div></div></body></html>