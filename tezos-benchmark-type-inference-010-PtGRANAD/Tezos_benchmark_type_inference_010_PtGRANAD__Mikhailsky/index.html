<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tezos_benchmark_type_inference_010_PtGRANAD__Mikhailsky (tezos-benchmark-type-inference-010-PtGRANAD.Tezos_benchmark_type_inference_010_PtGRANAD__Mikhailsky)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">tezos-benchmark-type-inference-010-PtGRANAD</a> &#x00BB; Tezos_benchmark_type_inference_010_PtGRANAD__Mikhailsky</nav><h1>Module <code>Tezos_benchmark_type_inference_010_PtGRANAD__Mikhailsky</code></h1></header><aside><p>Mikhailsky: Michelson in Micheline form, with typed holes and annotations. Mikhailsky terms are hash-consed.</p></aside><aside><p>Michelson code is a hard to type-check and generate incrementally due to the presence of ambiguous constructs, such as literals like <code>{ 1 ; 2 ; 3 }</code>. Is it a list of ints? of nats? of tez? Or a set?</p><p>Thus, we will work with Mikhailsky, a better behaved version of Michelson allowing local reconstruction of types.</p><p>Differences wrt Michelson:</p><p>1. non string/byte literals are explicitly annotated with their head type constructor. Here is an int i: Prim (_, D_int, <code>Int i</code>, _) Here is an nat n: Prim (_, D_nat, <code>Int i</code>, _) Here is an list of something: Prim (_, D_list, michelson_list, _) Here is a set: Prim (_, D_set, michelson_set, _) Here is a map: Prim (_, D_map, michelson_map, _) etc. Projecting back from this language to Michelson is trivial.</p><p>2. Instructions `LEFT/RIGHT` do not need to carry the type of the other component of the disjunction. These has to be filled in back when generating Michelson from Mikhailsky.</p><p>4. The same holds for the input/output type of a lambda as specified in the `LAMBDA` instruction.</p><p>3. Some instructions are annotated with the type on which they operate. Eg if Prim (_, I_ADD, <code></code>, <code></code>) is the (ad-hoc polymorphic) addition in Michelson, we will have the following variants in Mikhailsky:</p><ul><li>Prim (_, I_ADD, <code> Prim (_, T_mutez, [], []),
                          Prim (_, T_mutez, [], []) </code>, <code></code>) for mutez addition</li><li>Prim (_, I_ADD, <code> Prim (_, T_int, [], []),
                          Prim (_, T_nat, [], []) </code>, <code></code>) for int+nat addition etc.</li></ul></aside><dl><dt class="spec module" id="module-Mikhailsky_signature"><a href="#module-Mikhailsky_signature" class="anchor"></a><code><span class="keyword">module</span> <a href="Mikhailsky_signature/index.html">Mikhailsky_signature</a> : <a href="../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Signature/index.html#module-type-S">Tezos_micheline_rewriting.Signature.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Signature/module-type-S/index.html#type-t">t</a> = <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Mikhailsky_prim/index.html#type-prim">Tezos_benchmark_type_inference_010_PtGRANAD.Mikhailsky_prim.prim</a></code></dt><dd><p>The signature of Mikhailsky terms.</p></dd></dl><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <a href="../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Path/index.html#module-type-S">Tezos_micheline_rewriting.Path.S</a></code></dt><dd><p>Elements of type <code>Path.t</code> allow to index subterms of Mikhailsky terms.</p></dd></dl><dl><dt class="spec type" id="type-label"><a href="#type-label" class="anchor"></a><code><span class="keyword">type</span> label</code><code> = <a href="../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Micheline_with_hash_consing/index.html#type-hcons_info">Tezos_micheline_rewriting.Micheline_with_hash_consing.hcons_info</a></code></dt><dd><p>The following types correspond to those provided when instantiating the functor <code>Micheline_with_hash_consing.Make</code> on <code>Mikhailsky_signature</code>.</p></dd></dl><dl><dt class="spec type" id="type-head"><a href="#type-head" class="anchor"></a><code><span class="keyword">type</span> head</code><code> = <a href="Mikhailsky_signature/index.html#type-t">Mikhailsky_signature.t</a></code></dt><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> node</code><code> = <span><span>(<a href="index.html#type-label">label</a>, <a href="index.html#type-head">head</a>)</span> <a href="../../tezos-micheline/Tezos_micheline/Micheline/index.html#type-node">Tezos_micheline.Micheline.node</a></span></code></dt></dl><dl><dt class="spec exception" id="exception-Term_contains_holes"><a href="#exception-Term_contains_holes" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Term_contains_holes</span></code></dt><dt class="spec exception" id="exception-Ill_formed_mikhailsky"><a href="#exception-Ill_formed_mikhailsky" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Ill_formed_mikhailsky</span></code></dt></dl><dl><dt class="spec value" id="val-parse_ty"><a href="#val-parse_ty" class="anchor"></a><code><span class="keyword">val</span> parse_ty : <span>allow_big_map:bool</span> <span>&#45;&gt;</span> <span>allow_operation:bool</span> <span>&#45;&gt;</span> <span>allow_contract:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Type/Base/index.html#type-t">Tezos_benchmark_type_inference_010_PtGRANAD.Type.Base.t</a></code></dt><dd><p><code>parse_ty</code> returns a type from a Mikhailsky term.</p></dd></dl><dl><dt class="spec value" id="val-map_var"><a href="#val-map_var" class="anchor"></a><code><span class="keyword">val</span> map_var : <span>(int <span>&#45;&gt;</span> <a href="index.html#type-node">node</a>)</span> <span>&#45;&gt;</span> <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Type/Base/index.html#type-t">Tezos_benchmark_type_inference_010_PtGRANAD.Type.Base.t</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p><code>map_var f x</code> maps the function f on all variables contained in the type <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-unparse_ty_exn"><a href="#val-unparse_ty_exn" class="anchor"></a><code><span class="keyword">val</span> unparse_ty_exn : <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Type/Base/index.html#type-t">Tezos_benchmark_type_inference_010_PtGRANAD.Type.Base.t</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p><code>unparse_ty</code> returns a Mikhailsky term representing a type.</p></dd></dl><dl><dt class="spec value" id="val-unparse_ty"><a href="#val-unparse_ty" class="anchor"></a><code><span class="keyword">val</span> unparse_ty : <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Type/Base/index.html#type-t">Tezos_benchmark_type_inference_010_PtGRANAD.Type.Base.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-node">node</a> option</span></code></dt><dt class="spec value" id="val-to_michelson"><a href="#val-to_michelson" class="anchor"></a><code><span class="keyword">val</span> to_michelson : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="../../tezos-protocol-010-PtGRANAD/Tezos_raw_protocol_010_PtGRANAD/Script_repr/index.html#type-expr">Tezos_raw_protocol_010_PtGRANAD.Script_repr.expr</a></code></dt><dd><p>Extracts a Michelson term from a Mikhailsky one. Raises <code>Term_contains_holes</code> if it cannot be done.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the number of nodes of a Mikhailsky term.</p></dd></dl><dl><dt class="spec value" id="val-prim"><a href="#val-prim" class="anchor"></a><code><span class="keyword">val</span> prim : <a href="../Tezos_benchmark_type_inference_010_PtGRANAD/Mikhailsky_prim/index.html#type-prim">Tezos_benchmark_type_inference_010_PtGRANAD.Mikhailsky_prim.prim</a> <span>&#45;&gt;</span> <span><a href="index.html#type-node">node</a> list</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p>Micheline generic constructors</p></dd></dl><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <span><a href="index.html#type-node">node</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span class="keyword">val</span> bytes : Stdlib.Bytes.t <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt></dl><aside><p>Mikhailsky smart constructors</p></aside><dl><dt class="spec value" id="val-instr_hole"><a href="#val-instr_hole" class="anchor"></a><code><span class="keyword">val</span> instr_hole : <a href="index.html#type-node">node</a></code></dt><dd><p>Holes</p></dd></dl><dl><dt class="spec value" id="val-data_hole"><a href="#val-data_hole" class="anchor"></a><code><span class="keyword">val</span> data_hole : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-unit_ty"><a href="#val-unit_ty" class="anchor"></a><code><span class="keyword">val</span> unit_ty : <a href="index.html#type-node">node</a></code></dt><dd><p>Types</p></dd></dl><dl><dt class="spec value" id="val-int_ty"><a href="#val-int_ty" class="anchor"></a><code><span class="keyword">val</span> int_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-nat_ty"><a href="#val-nat_ty" class="anchor"></a><code><span class="keyword">val</span> nat_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-bool_ty"><a href="#val-bool_ty" class="anchor"></a><code><span class="keyword">val</span> bool_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-string_ty"><a href="#val-string_ty" class="anchor"></a><code><span class="keyword">val</span> string_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-bytes_ty"><a href="#val-bytes_ty" class="anchor"></a><code><span class="keyword">val</span> bytes_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-key_hash_ty"><a href="#val-key_hash_ty" class="anchor"></a><code><span class="keyword">val</span> key_hash_ty : <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-option_ty"><a href="#val-option_ty" class="anchor"></a><code><span class="keyword">val</span> option_ty : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-list_ty"><a href="#val-list_ty" class="anchor"></a><code><span class="keyword">val</span> list_ty : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dt class="spec value" id="val-tag"><a href="#val-tag" class="anchor"></a><code><span class="keyword">val</span> tag : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Project unique tag out of Mikhailsky node</p></dd></dl><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Project hash out of Mikhailsky node</p></dd></dl><dl><dt class="spec module" id="module-Instructions"><a href="#module-Instructions" class="anchor"></a><code><span class="keyword">module</span> <a href="Instructions/index.html">Instructions</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Instructions</p></dd></dl><dl><dt class="spec module" id="module-Data"><a href="#module-Data" class="anchor"></a><code><span class="keyword">module</span> <a href="Data/index.html">Data</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>data</p></dd></dl></div></body></html>