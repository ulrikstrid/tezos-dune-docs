<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mikhailsky (tezos-benchmark-type-inference-010-PtGRANAD.Tezos_benchmark_type_inference_010_PtGRANAD.Mikhailsky)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">tezos-benchmark-type-inference-010-PtGRANAD</a> &#x00BB; <a href="../index.html">Tezos_benchmark_type_inference_010_PtGRANAD</a> &#x00BB; Mikhailsky</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_benchmark_type_inference_010_PtGRANAD.Mikhailsky</span></code></h1><p>Mikhailsky: Michelson in Micheline form, with typed holes and annotations. Mikhailsky terms are hash-consed.</p></header><div class="odoc-content"><p>Michelson code is a hard to type-check and generate incrementally due to the presence of ambiguous constructs, such as literals like <code>{ 1 ; 2 ; 3 }</code>. Is it a list of ints? of nats? of tez? Or a set?</p><p>Thus, we will work with Mikhailsky, a better behaved version of Michelson allowing local reconstruction of types.</p><p>Differences wrt Michelson:</p><p>1. non string/byte literals are explicitly annotated with their head type constructor. Here is an int i: Prim (_, D_int, <code>Int i</code>, _) Here is an nat n: Prim (_, D_nat, <code>Int i</code>, _) Here is an list of something: Prim (_, D_list, michelson_list, _) Here is a set: Prim (_, D_set, michelson_set, _) Here is a map: Prim (_, D_map, michelson_map, _) etc. Projecting back from this language to Michelson is trivial.</p><p>2. Instructions `LEFT/RIGHT` do not need to carry the type of the other component of the disjunction. These has to be filled in back when generating Michelson from Mikhailsky.</p><p>4. The same holds for the input/output type of a lambda as specified in the `LAMBDA` instruction.</p><p>3. Some instructions are annotated with the type on which they operate. Eg if Prim (_, I_ADD, , ) is the (ad-hoc polymorphic) addition in Michelson, we will have the following variants in Mikhailsky:</p><ul><li>Prim (_, I_ADD, <code> Prim (_, T_mutez, [], []),
                          Prim (_, T_mutez, [], []) </code>, ) for mutez addition</li><li>Prim (_, I_ADD, <code> Prim (_, T_int, [], []),
                          Prim (_, T_nat, [], []) </code>, ) for int+nat addition etc.</li></ul><div class="odoc-spec"><div class="spec module" id="module-Mikhailsky_signature" class="anchored"><a href="#module-Mikhailsky_signature" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Mikhailsky_signature/index.html">Mikhailsky_signature</a></span><span> : <a href="../../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Signature/module-type-S/index.html">Tezos_micheline_rewriting.Signature.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Signature/module-type-S/index.html#type-t">t</a> = <a href="../Mikhailsky_prim/index.html#type-prim">Mikhailsky_prim.prim</a></span></span></code></div><div class="spec-doc"><p>The signature of Mikhailsky terms.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Path" class="anchored"><a href="#module-Path" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Path/index.html">Path</a></span><span> : <a href="../../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Path/module-type-S/index.html">Tezos_micheline_rewriting.Path.S</a></span></code></div><div class="spec-doc"><p>Elements of type <code>Path.t</code> allow to index subterms of Mikhailsky terms.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-label" class="anchored"><a href="#type-label" class="anchor"></a><code><span><span class="keyword">type</span> label</span><span> = <a href="../../../tezos-micheline-rewriting/Tezos_micheline_rewriting/Micheline_with_hash_consing/index.html#type-hcons_info">Tezos_micheline_rewriting.Micheline_with_hash_consing.hcons_info</a></span></code></div><div class="spec-doc"><p>The following types correspond to those provided when instantiating the functor <code>Micheline_with_hash_consing.Make</code> on <code>Mikhailsky_signature</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-head" class="anchored"><a href="#type-head" class="anchor"></a><code><span><span class="keyword">type</span> head</span><span> = <a href="Mikhailsky_signature/index.html#type-t">Mikhailsky_signature.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-node" class="anchored"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> node</span><span> = <span><span>(<a href="#type-label">label</a>, <a href="#type-head">head</a>)</span> <a href="../../../tezos-micheline/Tezos_micheline/Micheline/index.html#type-node">Tezos_micheline.Micheline.node</a></span></span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Term_contains_holes" class="anchored"><a href="#exception-Term_contains_holes" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Term_contains_holes</span></span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Ill_formed_mikhailsky" class="anchored"><a href="#exception-Ill_formed_mikhailsky" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Ill_formed_mikhailsky</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_ty" class="anchored"><a href="#val-parse_ty" class="anchor"></a><code><span><span class="keyword">val</span> parse_ty : <span>allow_big_map:bool <span class="arrow">&#45;&gt;</span></span> <span>allow_operation:bool <span class="arrow">&#45;&gt;</span></span> <span>allow_contract:bool <span class="arrow">&#45;&gt;</span></span>
<span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Type/Base/index.html#type-t">Type.Base.t</a></span></code></div><div class="spec-doc"><p><code>parse_ty</code> returns a type from a Mikhailsky term.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_var" class="anchored"><a href="#val-map_var" class="anchor"></a><code><span><span class="keyword">val</span> map_var : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Type/Base/index.html#type-t">Type.Base.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p><code>map_var f x</code> maps the function f on all variables contained in the type <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unparse_ty_exn" class="anchored"><a href="#val-unparse_ty_exn" class="anchor"></a><code><span><span class="keyword">val</span> unparse_ty_exn : <span><a href="../Type/Base/index.html#type-t">Type.Base.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p><code>unparse_ty</code> returns a Mikhailsky term representing a type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unparse_ty" class="anchored"><a href="#val-unparse_ty" class="anchor"></a><code><span><span class="keyword">val</span> unparse_ty : <span><a href="../Type/Base/index.html#type-t">Type.Base.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-to_michelson" class="anchored"><a href="#val-to_michelson" class="anchor"></a><code><span><span class="keyword">val</span> to_michelson : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../tezos-protocol-010-PtGRANAD/Tezos_raw_protocol_010_PtGRANAD/Script_repr/index.html#type-expr">Tezos_protocol_010_PtGRANAD.Protocol.Script_repr.expr</a></span></code></div><div class="spec-doc"><p>Extracts a Michelson term from a Mikhailsky one. Raises <code>Term_contains_holes</code> if it cannot be done.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-size" class="anchored"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Returns the number of nodes of a Mikhailsky term.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prim" class="anchored"><a href="#val-prim" class="anchor"></a><code><span><span class="keyword">val</span> prim : <span><a href="../Mikhailsky_prim/index.html#type-prim">Mikhailsky_prim.prim</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-node">node</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Micheline generic constructors</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span><a href="#type-node">node</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes" class="anchored"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><p>Mikhailsky smart constructors</p><div class="odoc-spec"><div class="spec value" id="val-instr_hole" class="anchored"><a href="#val-instr_hole" class="anchor"></a><code><span><span class="keyword">val</span> instr_hole : <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Holes</p></div></div><div class="odoc-spec"><div class="spec value" id="val-data_hole" class="anchored"><a href="#val-data_hole" class="anchor"></a><code><span><span class="keyword">val</span> data_hole : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unit_ty" class="anchored"><a href="#val-unit_ty" class="anchor"></a><code><span><span class="keyword">val</span> unit_ty : <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_ty" class="anchored"><a href="#val-int_ty" class="anchor"></a><code><span><span class="keyword">val</span> int_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-nat_ty" class="anchored"><a href="#val-nat_ty" class="anchor"></a><code><span><span class="keyword">val</span> nat_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bool_ty" class="anchored"><a href="#val-bool_ty" class="anchor"></a><code><span><span class="keyword">val</span> bool_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_ty" class="anchored"><a href="#val-string_ty" class="anchor"></a><code><span><span class="keyword">val</span> string_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes_ty" class="anchored"><a href="#val-bytes_ty" class="anchor"></a><code><span><span class="keyword">val</span> bytes_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-key_hash_ty" class="anchored"><a href="#val-key_hash_ty" class="anchor"></a><code><span><span class="keyword">val</span> key_hash_ty : <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-option_ty" class="anchored"><a href="#val-option_ty" class="anchor"></a><code><span><span class="keyword">val</span> option_ty : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-list_ty" class="anchored"><a href="#val-list_ty" class="anchor"></a><code><span><span class="keyword">val</span> list_ty : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tag" class="anchored"><a href="#val-tag" class="anchor"></a><code><span><span class="keyword">val</span> tag : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Project unique tag out of Mikhailsky node</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Project hash out of Mikhailsky node</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Instructions" class="anchored"><a href="#module-Instructions" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Instructions/index.html">Instructions</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Instructions</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Data" class="anchored"><a href="#module-Data" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Data/index.html">Data</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>data</p></div></div></div></body></html>